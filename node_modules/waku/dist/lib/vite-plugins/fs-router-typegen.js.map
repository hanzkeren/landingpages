{"version":3,"sources":["../../../src/lib/vite-plugins/fs-router-typegen.ts"],"sourcesContent":["import { existsSync, readFileSync } from 'node:fs';\nimport { readdir, writeFile } from 'node:fs/promises';\nimport type * as estree from 'estree';\nimport type { Plugin } from 'vite';\nimport { parseAstAsync, transformWithEsbuild } from 'vite';\nimport { EXTENSIONS, SRC_PAGES, SRC_SERVER_ENTRY } from '../constants.js';\nimport { getGrouplessPath } from '../utils/create-pages.js';\nimport { isIgnoredPath } from '../utils/fs-router.js';\nimport { joinPath } from '../utils/path.js';\n\n// https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-names-and-keywords\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_words\nexport function toIdentifier(input: string): string {\n  // Strip the file extension\n  let identifier = input.includes('.')\n    ? input.split('.').slice(0, -1).join('.')\n    : input;\n  // Replace any characters besides letters, numbers, underscores, and dollar signs with underscores\n  identifier = identifier.replace(/[^\\p{L}\\p{N}_$]/gu, '_');\n  // Ensure it starts with a letter\n  if (/^\\d/.test(identifier)) {\n    identifier = '_' + identifier;\n  }\n  // Turn it into PascalCase\n  // Since the first letter is uppercased, it will not be a reserved word\n  return (\n    'File_' +\n    identifier\n      .split('_')\n      .map((part) => {\n        if (part[0] === undefined) {\n          return '';\n        }\n        return part[0].toUpperCase() + part.slice(1);\n      })\n      .join('')\n  );\n}\n\nexport function getImportModuleNames(filePaths: string[]): {\n  [k: string]: string;\n} {\n  const moduleNameCount: { [k: string]: number } = {};\n  const moduleNames: { [k: string]: string } = {};\n  for (const filePath of filePaths) {\n    let identifier = toIdentifier(filePath);\n    moduleNameCount[identifier] = (moduleNameCount[identifier] ?? -1) + 1;\n    if (moduleNameCount[identifier]) {\n      identifier = `${identifier}_${moduleNameCount[identifier]}`;\n    }\n    try {\n      moduleNames[filePath.replace(/^\\//, '')] = identifier;\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  return moduleNames;\n}\n\nconst parseModule = async (filePath: string) => {\n  const source = readFileSync(filePath, 'utf8');\n  const loader: 'jsx' | 'ts' | 'tsx' = filePath.endsWith('.tsx')\n    ? 'tsx'\n    : filePath.endsWith('.ts')\n      ? 'ts'\n      : 'jsx';\n  const transformed = await transformWithEsbuild(source, filePath, {\n    loader,\n    jsx: 'preserve',\n  });\n  return parseAstAsync(transformed.code, { jsx: true });\n};\n\nconst getImportedName = (specifier: estree.ImportSpecifier) =>\n  specifier.imported.type === 'Identifier'\n    ? specifier.imported.name\n    : String(specifier.imported.value);\n\nconst getExportedName = (specifier: estree.ExportSpecifier) =>\n  specifier.exported.type === 'Identifier'\n    ? specifier.exported.name\n    : String(specifier.exported.value);\n\nexport const fsRouterTypegenPlugin = (opts: { srcDir: string }): Plugin => {\n  return {\n    name: 'waku:vite-plugins:fs-router-typegen',\n    apply: 'serve',\n    configureServer(server) {\n      const srcDir = joinPath(server.config.root, opts.srcDir);\n      const pagesDir = joinPath(srcDir, SRC_PAGES);\n\n      const outputFile = joinPath(srcDir, 'pages.gen.ts');\n      const updateGeneratedFile = async (file: string | undefined) => {\n        // skip when the changed file is the generated file itself\n        if (file && outputFile.endsWith(file)) {\n          return;\n        }\n        // skip when the entries file exists or pages dir does not exist\n        if (!existsSync(pagesDir) || !(await detectFsRouterUsage(srcDir))) {\n          return;\n        }\n        const generation = await generateFsRouterTypes(pagesDir);\n        if (!generation) {\n          // skip failures\n          return;\n        }\n        await writeFile(outputFile, generation, 'utf-8');\n      };\n\n      server.watcher.on('change', async (file) => {\n        await updateGeneratedFile(file);\n      });\n      server.watcher.on('add', async (file) => {\n        await updateGeneratedFile(file);\n      });\n      server.watcher.on('unlink', async (file) => {\n        await updateGeneratedFile(file);\n      });\n      void updateGeneratedFile(undefined);\n    },\n  };\n};\n\nexport async function detectFsRouterUsage(srcDir: string): Promise<boolean> {\n  const existingServerEntry = EXTENSIONS.map((ext) =>\n    joinPath(srcDir, SRC_SERVER_ENTRY + ext),\n  ).find((entriesFile) => existsSync(entriesFile));\n\n  // managed mode if no entry\n  if (!existingServerEntry) {\n    return true;\n  }\n\n  try {\n    const file = await parseModule(existingServerEntry);\n    const usesFsRouter = file.body.some((node) => {\n      if (node.type !== 'ImportDeclaration') {\n        return false;\n      }\n      if (\n        node.source.type !== 'Literal' ||\n        typeof node.source.value !== 'string' ||\n        !node.source.value.startsWith('waku')\n      ) {\n        return false;\n      }\n      return node.specifiers.some((specifier) => {\n        if (\n          specifier.type !== 'ImportSpecifier' ||\n          specifier.local.type !== 'Identifier'\n        ) {\n          return false;\n        }\n        return getImportedName(specifier) === 'fsRouter';\n      });\n    });\n    return usesFsRouter;\n  } catch {\n    return false;\n  }\n}\n\nexport async function generateFsRouterTypes(pagesDir: string) {\n  // Recursively collect `.tsx` files in the given directory\n  const collectFiles = async (\n    dir: string,\n    files: string[] = [],\n  ): Promise<string[]> => {\n    // TODO revisit recursive option for readdir once more stable\n    // https://nodejs.org/docs/latest-v20.x/api/fs.html#direntparentpath\n    const entries = await readdir(dir, { withFileTypes: true });\n    for (const entry of entries) {\n      const fullPath = joinPath(dir, entry.name);\n      if (entry.isDirectory()) {\n        await collectFiles(fullPath, files);\n      } else {\n        if (entry.name.endsWith('.tsx')) {\n          files.push(fullPath.slice(pagesDir.length));\n        }\n      }\n    }\n    return files;\n  };\n\n  const fileExportsGetConfig = async (filePath: string) => {\n    const file = await parseModule(pagesDir + filePath);\n    return file.body.some((node) => {\n      if (node.type !== 'ExportNamedDeclaration') {\n        return false;\n      }\n      if (\n        node.declaration?.type === 'VariableDeclaration' &&\n        node.declaration.declarations.some(\n          (decl) =>\n            decl.id.type === 'Identifier' && decl.id.name === 'getConfig',\n        )\n      ) {\n        return true;\n      }\n      if (\n        node.declaration?.type === 'FunctionDeclaration' &&\n        node.declaration.id?.name === 'getConfig'\n      ) {\n        return true;\n      }\n      return node.specifiers.some(\n        (specifier) =>\n          specifier.type === 'ExportSpecifier' &&\n          getExportedName(specifier) === 'getConfig',\n      );\n    });\n  };\n\n  const generateFile = async (filePaths: string[]): Promise<string | null> => {\n    const fileInfo: { path: string; src: string; hasGetConfig: boolean }[] = [];\n    const moduleNames = getImportModuleNames(filePaths);\n\n    for (const filePath of filePaths) {\n      // where to import the component from\n      const src = filePath.replace(/^\\//, '');\n      let hasGetConfig = false;\n      try {\n        hasGetConfig = await fileExportsGetConfig(filePath);\n      } catch {\n        return null;\n      }\n\n      if (\n        filePath.endsWith('/_layout.tsx') ||\n        isIgnoredPath(filePath.split('/'))\n      ) {\n        continue;\n      } else if (filePath.endsWith('/index.tsx')) {\n        const path = filePath.slice(0, -'/index.tsx'.length);\n        fileInfo.push({\n          path: getGrouplessPath(path) || '/',\n          src,\n          hasGetConfig,\n        });\n      } else {\n        fileInfo.push({\n          path: getGrouplessPath(filePath.replace('.tsx', '')),\n          src,\n          hasGetConfig,\n        });\n      }\n    }\n\n    let result = `// deno-fmt-ignore-file\n// biome-ignore format: generated types do not need formatting\n// prettier-ignore\nimport type { PathsForPages, GetConfigResponse } from 'waku/router';\\n\\n`;\n\n    for (const file of fileInfo) {\n      const moduleName = moduleNames[file.src];\n      if (file.hasGetConfig) {\n        result += `// prettier-ignore\\nimport type { getConfig as ${moduleName}_getConfig } from './${SRC_PAGES}/${file.src.replace('.tsx', '')}';\\n`;\n      }\n    }\n\n    result += `\\n// prettier-ignore\\ntype Page =\\n`;\n\n    for (const file of fileInfo) {\n      const moduleName = moduleNames[file.src];\n      if (file.hasGetConfig) {\n        result += `| ({ path: '${file.path}' } & GetConfigResponse<typeof ${moduleName}_getConfig>)\\n`;\n      } else {\n        result += `| { path: '${file.path}'; render: 'dynamic' }\\n`;\n      }\n    }\n\n    result =\n      result.slice(0, -1) +\n      `;\n\n// prettier-ignore\ndeclare module 'waku/router' {\n  interface RouteConfig {\n    paths: PathsForPages<Page>;\n  }\n  interface CreatePagesConfig {\n    pages: Page;\n  }\n}\n`;\n\n    return result;\n  };\n\n  const files = await collectFiles(pagesDir);\n  if (!files.length) {\n    return;\n  }\n  const generation = await generateFile(files);\n  return generation;\n}\n"],"names":["existsSync","readFileSync","readdir","writeFile","parseAstAsync","transformWithEsbuild","EXTENSIONS","SRC_PAGES","SRC_SERVER_ENTRY","getGrouplessPath","isIgnoredPath","joinPath","toIdentifier","input","identifier","includes","split","slice","join","replace","test","map","part","undefined","toUpperCase","getImportModuleNames","filePaths","moduleNameCount","moduleNames","filePath","e","console","log","parseModule","source","loader","endsWith","transformed","jsx","code","getImportedName","specifier","imported","type","name","String","value","getExportedName","exported","fsRouterTypegenPlugin","opts","apply","configureServer","server","srcDir","config","root","pagesDir","outputFile","updateGeneratedFile","file","detectFsRouterUsage","generation","generateFsRouterTypes","watcher","on","existingServerEntry","ext","find","entriesFile","usesFsRouter","body","some","node","startsWith","specifiers","local","collectFiles","dir","files","entries","withFileTypes","entry","fullPath","isDirectory","push","length","fileExportsGetConfig","declaration","declarations","decl","id","generateFile","fileInfo","src","hasGetConfig","path","result","moduleName"],"mappings":"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"}