import { jsx as _jsx } from "react/jsx-runtime";
import { captureOwnerStack, use } from 'react';
import { createFromReadableStream } from '@vitejs/plugin-rsc/ssr';
import { renderToReadableStream } from 'react-dom/server.edge';
import { injectRSCPayload } from 'rsc-html-stream/server';
import fallbackHtml from 'virtual:vite-rsc-waku/fallback-html';
import { INTERNAL_ServerRoot } from '../../minimal/client.js';
import { getErrorInfo } from '../utils/custom-errors.js';
import { getBootstrapPreamble } from '../utils/ssr.js';
import { batchReadableStream } from '../utils/stream.js';
// This code runs on `ssr` environment,
// i.e. it runs on server but without `react-server` condition.
// These utilities are used by `rsc` environment through
// `import.meta.viteRsc.loadModule` API.
export const renderHtmlStream = async (rscStream, rscHtmlStream, options)=>{
    const [stream1, stream2] = rscStream.tee();
    let elementsPromise;
    let htmlPromise;
    // deserialize RSC stream back to React VDOM
    function SsrRoot() {
        // RSC stream needs to be deserialized inside SSR component.
        // This is for ReactDomServer preinit/preload (e.g. client reference modulepreload, css)
        // https://github.com/facebook/react/pull/31799#discussion_r1886166075
        elementsPromise ??= createFromReadableStream(stream1);
        htmlPromise ??= createFromReadableStream(rscHtmlStream);
        return /*#__PURE__*/ _jsx(INTERNAL_ServerRoot, {
            elementsPromise: elementsPromise,
            children: use(htmlPromise)
        });
    }
    // render html
    const bootstrapScriptContent = await loadBootstrapScriptContent();
    let htmlStream;
    let status;
    try {
        htmlStream = await renderToReadableStream(/*#__PURE__*/ _jsx(SsrRoot, {}), {
            bootstrapScriptContent: getBootstrapPreamble({
                rscPath: options?.rscPath || '',
                hydrate: true
            }) + bootstrapScriptContent,
            onError: (e)=>{
                if (e && typeof e === 'object' && 'digest' in e && typeof e.digest === 'string') {
                    return e.digest;
                }
                console.error('[SSR Error]', captureOwnerStack?.() || '', '\n', e);
            },
            ...options?.nonce ? {
                nonce: options.nonce
            } : {},
            ...options?.formState ? {
                formState: options.formState
            } : {}
        });
    } catch (e) {
        const info = getErrorInfo(e);
        if (info?.location) {
            // keep unstable_redirect error as http redirection
            throw e;
        }
        status = info?.status || 500;
        // SSR empty html and go full CSR on browser, which can revive RSC errors.
        const ssrErrorRoot = /*#__PURE__*/ _jsx("html", {
            children: /*#__PURE__*/ _jsx("body", {})
        });
        htmlStream = await renderToReadableStream(ssrErrorRoot, {
            bootstrapScriptContent: getBootstrapPreamble({
                rscPath: options?.rscPath || '',
                hydrate: false
            }) + bootstrapScriptContent,
            ...options?.nonce ? {
                nonce: options.nonce
            } : {}
        });
    }
    let responseStream = htmlStream;
    responseStream = responseStream.pipeThrough(injectRSCPayload(batchReadableStream(stream2), options?.nonce ? {
        nonce: options?.nonce
    } : {}));
    return {
        stream: responseStream,
        status
    };
};
export async function renderHtmlFallback() {
    const bootstrapScriptContent = await loadBootstrapScriptContent();
    const html = fallbackHtml.replace('</body>', ()=>`<script>${bootstrapScriptContent}</script></body>`);
    return html;
}
function loadBootstrapScriptContent() {
    return import.meta.viteRsc.loadBootstrapScriptContent('index');
}

//# sourceMappingURL=ssr.js.map