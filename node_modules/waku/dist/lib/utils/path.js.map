{"version":3,"sources":["../../../src/lib/utils/path.ts"],"sourcesContent":["// Terminology:\n// - filePath: posix-like file path, e.g. `/foo/bar.js` or `c:/foo/bar.js`\n//   This is used by Vite.\n// - fileURL: file URL, e.g. `file:///foo/bar.js` or `file:///c:/foo/bar.js`\n//   This is used by import().\n// - osPath: os dependent path, e.g. `/foo/bar.js` or `c:\\foo\\bar.js`\n//   This is used by node:fs.\n\nconst ABSOLUTE_WIN32_PATH_REGEXP = /^\\/[a-zA-Z]:\\//;\n\nexport const encodeFilePathToAbsolute = (filePath: string) => {\n  if (ABSOLUTE_WIN32_PATH_REGEXP.test(filePath)) {\n    throw new Error('Unsupported absolute file path: ' + filePath);\n  }\n  if (filePath.startsWith('/')) {\n    return filePath;\n  }\n  return '/' + filePath;\n};\n\nexport const decodeFilePathFromAbsolute = (filePath: string) => {\n  if (ABSOLUTE_WIN32_PATH_REGEXP.test(filePath)) {\n    return filePath.slice(1);\n  }\n  return filePath;\n};\n\nexport const filePathToFileURL = (filePath: string) =>\n  'file://' + encodeURI(filePath);\n\nexport const fileURLToFilePath = (fileURL: string) => {\n  if (!fileURL.startsWith('file://')) {\n    throw new Error('Not a file URL');\n  }\n  return decodeURI(fileURL.slice('file://'.length));\n};\n\n// for filePath\nexport const joinPath = (...paths: string[]) => {\n  const isAbsolute = paths[0]?.startsWith('/');\n  const items = ([] as string[]).concat(\n    ...paths.map((path) => path.split('/')),\n  );\n  const stack: string[] = [];\n  for (const item of items) {\n    if (item === '..') {\n      if (stack.length && stack[stack.length - 1] !== '..') {\n        stack.pop();\n      } else if (!isAbsolute) {\n        stack.push('..');\n      }\n    } else if (item && item !== '.') {\n      stack.push(item);\n    }\n  }\n  return (isAbsolute ? '/' : '') + stack.join('/') || '.';\n};\n\nexport const extname = (filePath: string) => {\n  const index = filePath.lastIndexOf('.');\n  if (index <= 0) {\n    return '';\n  }\n  if (['/', '.'].includes(filePath[index - 1]!)) {\n    return '';\n  }\n  return filePath.slice(index);\n};\n\nexport type PathSpecItem =\n  | { type: 'literal'; name: string }\n  | { type: 'group'; name?: string }\n  | { type: 'wildcard'; name?: string };\nexport type PathSpec = readonly PathSpecItem[];\n\nexport const parsePathWithSlug = (path: string): PathSpec =>\n  path\n    .split('/')\n    .filter(Boolean)\n    .map((name) => {\n      let type: 'literal' | 'group' | 'wildcard' = 'literal';\n      const isSlug = name.startsWith('[') && name.endsWith(']');\n      if (isSlug) {\n        type = 'group';\n        name = name.slice(1, -1);\n      }\n      const isWildcard = name.startsWith('...');\n      if (isWildcard) {\n        type = 'wildcard';\n        name = name.slice(3);\n      }\n      return { type, name };\n    });\n\nexport const parseExactPath = (path: string): PathSpec =>\n  path\n    .split('/')\n    .filter(Boolean)\n    .map((name) => ({ type: 'literal', name }));\n\n/**\n * Transform a path spec to a regular expression.\n */\nexport const path2regexp = (path: PathSpec) => {\n  const parts = path.map(({ type, name }) => {\n    if (type === 'literal') {\n      return name;\n    } else if (type === 'group') {\n      return `([^/]+)`;\n    } else {\n      return `(.*)`;\n    }\n  });\n  return `^/${parts.join('/')}$`;\n};\n\n/** Convert a path spec to a string for the path */\nexport const pathSpecAsString = (path: PathSpec) => {\n  return (\n    '/' +\n    path\n      .map(({ type, name }) => {\n        if (type === 'literal') {\n          return name;\n        } else if (type === 'group') {\n          return `[${name}]`;\n        } else {\n          return `[...${name}]`;\n        }\n      })\n      .join('/')\n  );\n};\n\n/**\n * Helper function to get the path mapping from the path spec and the pathname.\n *\n * @param pathSpec\n * @param pathname - route as a string\n * @example\n * getPathMapping(\n *   [\n *     { type: 'literal', name: 'foo' },\n *     { type: 'group', name: 'a' },\n *   ],\n *   '/foo/bar',\n * );\n * // => { a: 'bar' }\n */\nexport const getPathMapping = (\n  pathSpec: PathSpec,\n  pathname: string,\n): Record<string, string | string[]> | null => {\n  const actual = pathname.split('/').filter(Boolean);\n  if (pathSpec.length > actual.length) {\n    const hasWildcard = pathSpec.some((spec) => spec.type === 'wildcard');\n    if (!hasWildcard || actual.length > 0) {\n      return null;\n    }\n  }\n  const mapping: Record<string, string | string[]> = {};\n  let wildcardStartIndex = -1;\n  for (let i = 0; i < pathSpec.length; i++) {\n    const { type, name } = pathSpec[i]!;\n    if (type === 'literal') {\n      if (name !== actual[i]) {\n        return null;\n      }\n    } else if (type === 'wildcard') {\n      wildcardStartIndex = i;\n      break;\n    } else if (name) {\n      mapping[name] = actual[i]!;\n    }\n  }\n  if (wildcardStartIndex === -1) {\n    if (pathSpec.length !== actual.length) {\n      return null;\n    }\n    return mapping;\n  }\n\n  if (wildcardStartIndex === 0 && actual.length === 0) {\n    const wildcardName = pathSpec[wildcardStartIndex]!.name;\n    if (wildcardName) {\n      mapping[wildcardName] = [];\n    }\n    return mapping;\n  }\n\n  let wildcardEndIndex = -1;\n  for (let i = 0; i < pathSpec.length; i++) {\n    const { type, name } = pathSpec[pathSpec.length - i - 1]!;\n    if (type === 'literal') {\n      if (name !== actual[actual.length - i - 1]) {\n        return null;\n      }\n    } else if (type === 'wildcard') {\n      wildcardEndIndex = actual.length - i - 1;\n      break;\n    } else if (name) {\n      mapping[name] = actual[actual.length - i - 1]!;\n    }\n  }\n  if (wildcardStartIndex === -1 || wildcardEndIndex === -1) {\n    throw new Error('Invalid wildcard path');\n  }\n  const wildcardName = pathSpec[wildcardStartIndex]!.name;\n  if (wildcardName) {\n    mapping[wildcardName] = actual.slice(\n      wildcardStartIndex,\n      wildcardEndIndex + 1,\n    );\n  }\n  return mapping;\n};\n\n// basePath config is ensured to have trailing slash (see plugin)\nexport function removeBase(url: string, base: string) {\n  if (base !== '/') {\n    if (!url.startsWith(base)) {\n      throw new Error('pathname must start with basePath: ' + url);\n    }\n    return url.slice(base.length - 1);\n  }\n  return url;\n}\n\nexport function addBase(url: string, base: string) {\n  if (base !== '/' && url.startsWith('/')) {\n    return base.slice(0, -1) + url;\n  }\n  return url;\n}\n"],"names":["ABSOLUTE_WIN32_PATH_REGEXP","encodeFilePathToAbsolute","filePath","test","Error","startsWith","decodeFilePathFromAbsolute","slice","filePathToFileURL","encodeURI","fileURLToFilePath","fileURL","decodeURI","length","joinPath","paths","isAbsolute","items","concat","map","path","split","stack","item","pop","push","join","extname","index","lastIndexOf","includes","parsePathWithSlug","filter","Boolean","name","type","isSlug","endsWith","isWildcard","parseExactPath","path2regexp","parts","pathSpecAsString","getPathMapping","pathSpec","pathname","actual","hasWildcard","some","spec","mapping","wildcardStartIndex","i","wildcardName","wildcardEndIndex","removeBase","url","base","addBase"],"mappings":"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"}