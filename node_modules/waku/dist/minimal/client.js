'use client';
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { createContext, memo, startTransition, use, useCallback, useEffect, useMemo, useState } from 'react';
import RSDWClient from 'react-server-dom-webpack/client';
import { createCustomError } from '../lib/utils/custom-errors.js';
import { encodeFuncId, encodeRscPath } from '../lib/utils/rsc-path.js';
const { createFromFetch, encodeReply, createTemporaryReferenceSet } = RSDWClient;
const DEFAULT_HTML_HEAD = [
    /*#__PURE__*/ _jsx("meta", {
        charSet: "utf-8"
    }, "charset"),
    /*#__PURE__*/ _jsx("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1"
    }, "viewport"),
    /*#__PURE__*/ _jsx("meta", {
        name: "generator",
        content: "Waku"
    }, "generator")
];
const BASE_RSC_PATH = `${import.meta.env?.WAKU_CONFIG_BASE_PATH}${import.meta.env?.WAKU_CONFIG_RSC_BASE}/`;
const checkStatus = async (responsePromise)=>{
    const response = await responsePromise;
    if (!response.ok) {
        const location = response.headers.get('location');
        const err = createCustomError(await response.text() || response.statusText, {
            status: response.status,
            ...location && {
                location
            }
        });
        throw err;
    }
    return response;
};
// TODO(daishi) do we still this?
const getCached = (c, m, k)=>(m.has(k) ? m : m.set(k, c())).get(k);
const cache1 = new WeakMap();
const mergeElementsPromise = (a, b)=>{
    const getResult = ()=>Promise.all([
            a,
            b
        ]).then(([a, b])=>{
            const nextElements = {
                ...a,
                ...b
            };
            delete nextElements._value;
            return nextElements;
        });
    const cache2 = getCached(()=>new WeakMap(), cache1, a);
    return getCached(getResult, cache2, b);
};
const ENTRY = 'e';
const SET_ELEMENTS = 's';
const FETCH_RSC_INTERNAL = 'f';
const defaultFetchCache = {};
const createFetchRscInternal = (fetchCache)=>(rscPath, rscParams, prefetchOnly, fetchFn = fetch)=>{
        const prefetched = globalThis.__WAKU_PREFETCHED__ ||= {};
        let prefetchedEntry = prefetchOnly ? undefined : prefetched[rscPath];
        delete prefetched[rscPath];
        if (prefetchedEntry) {
            if (Array.isArray(prefetchedEntry)) {
                if (prefetchedEntry[1] !== rscParams) {
                    prefetchedEntry = undefined;
                }
            } else {
                // We don't check rscParams for the initial hydration
                // It's limited and may result in a wrong result. FIXME
                prefetchedEntry = [
                    prefetchedEntry
                ];
            }
        }
        const temporaryReferences = prefetchedEntry?.[2] || createTemporaryReferenceSet();
        const url = BASE_RSC_PATH + encodeRscPath(rscPath);
        const responsePromise = prefetchedEntry ? prefetchedEntry[0] : rscParams === undefined ? fetchFn(url) : rscParams instanceof URLSearchParams ? fetchFn(url + '?' + rscParams) : encodeReply(rscParams, {
            temporaryReferences
        }).then((body)=>fetchFn(url, {
                method: 'POST',
                body
            }));
        if (prefetchOnly) {
            prefetched[rscPath] = [
                responsePromise,
                rscParams,
                temporaryReferences
            ];
            return undefined;
        }
        return createFromFetch(checkStatus(responsePromise), {
            callServer: (funcId, args)=>unstable_callServerRsc(funcId, args, fetchCache),
            temporaryReferences
        });
    };
/**
 * callServer callback
 * This is not a public API.
 */ export const unstable_callServerRsc = async (funcId, args, fetchCache = defaultFetchCache)=>{
    const setElements = fetchCache[SET_ELEMENTS];
    const fetchRscInternal = fetchCache[FETCH_RSC_INTERNAL];
    const rscPath = encodeFuncId(funcId);
    const rscParams = args.length === 1 && args[0] instanceof URLSearchParams ? args[0] : args;
    const { _value: value, ...data } = await fetchRscInternal(rscPath, rscParams);
    if (Object.keys(data).length) {
        startTransition(()=>{
            setElements((prev)=>mergeElementsPromise(prev, data));
        });
    }
    return value;
};
export const fetchRsc = (rscPath, rscParams, fetchCache = defaultFetchCache)=>{
    if (import.meta.hot) {
        const refetchRsc = ()=>{
            delete fetchCache[ENTRY];
            const data = fetchRsc(rscPath, rscParams, fetchCache);
            fetchCache[SET_ELEMENTS](()=>data);
        };
        globalThis.__WAKU_RSC_RELOAD_LISTENERS__ ||= [];
        const index = globalThis.__WAKU_RSC_RELOAD_LISTENERS__.indexOf(globalThis.__WAKU_REFETCH_RSC__);
        if (index !== -1) {
            globalThis.__WAKU_RSC_RELOAD_LISTENERS__.splice(index, 1, refetchRsc);
        } else {
            globalThis.__WAKU_RSC_RELOAD_LISTENERS__.push(refetchRsc);
        }
        globalThis.__WAKU_REFETCH_RSC__ = refetchRsc;
    }
    const fetchRscInternal = fetchCache[FETCH_RSC_INTERNAL];
    const entry = fetchCache[ENTRY];
    if (entry && entry[0] === rscPath && entry[1] === rscParams) {
        return entry[2];
    }
    const data = fetchRscInternal(rscPath, rscParams);
    fetchCache[ENTRY] = [
        rscPath,
        rscParams,
        data
    ];
    return data;
};
export const prefetchRsc = (rscPath, rscParams, fetchCache = defaultFetchCache)=>{
    const fetchRscInternal = fetchCache[FETCH_RSC_INTERNAL];
    const prefetched = globalThis.__WAKU_PREFETCHED__ ||= {};
    const prefetchedEntry = prefetched[rscPath];
    if (Array.isArray(prefetchedEntry) && prefetchedEntry[1] === rscParams) {
        return; // already prefetched
    }
    fetchRscInternal(rscPath, rscParams, true);
};
const RefetchContext = /*#__PURE__*/ createContext(()=>{
    throw new Error('Missing Root component');
});
const ElementsContext = /*#__PURE__*/ createContext(null);
const EnhanceFetchRscInternalContext = /*#__PURE__*/ createContext(()=>{
    throw new Error('Missing Root component');
});
export const useEnhanceFetchRscInternal_UNSTABLE = ()=>use(EnhanceFetchRscInternalContext);
export const Root = ({ initialRscPath, initialRscParams, fetchCache = defaultFetchCache, children })=>{
    fetchCache[FETCH_RSC_INTERNAL] ||= createFetchRscInternal(fetchCache);
    const enhanceFetchRscInternal = useMemo(()=>{
        const enhancers = new Set();
        const enhance = ()=>{
            let fetchRscInternal = createFetchRscInternal(fetchCache);
            for (const fn of enhancers){
                fetchRscInternal = fn(fetchRscInternal);
            }
            fetchCache[FETCH_RSC_INTERNAL] = fetchRscInternal;
        };
        return (fn)=>{
            enhancers.add(fn);
            enhance();
            return ()=>{
                enhancers.delete(fn);
                enhance();
            };
        };
    }, [
        fetchCache
    ]);
    const [elements, setElements] = useState(()=>fetchRsc(initialRscPath || '', initialRscParams, fetchCache));
    useEffect(()=>{
        fetchCache[SET_ELEMENTS] = setElements;
    }, [
        fetchCache
    ]);
    const refetch = useCallback(async (rscPath, rscParams)=>{
        // clear cache entry before fetching
        delete fetchCache[ENTRY];
        const data = fetchRsc(rscPath, rscParams, fetchCache);
        const dataWithoutErrors = Promise.resolve(data).catch(()=>({}));
        setElements((prev)=>mergeElementsPromise(prev, dataWithoutErrors));
        await data;
    }, [
        fetchCache
    ]);
    return /*#__PURE__*/ _jsx(EnhanceFetchRscInternalContext, {
        value: enhanceFetchRscInternal,
        children: /*#__PURE__*/ _jsx(RefetchContext, {
            value: refetch,
            children: /*#__PURE__*/ _jsxs(ElementsContext, {
                value: elements,
                children: [
                    DEFAULT_HTML_HEAD,
                    children
                ]
            })
        })
    });
};
export const useRefetch = ()=>use(RefetchContext);
const ChildrenContext = /*#__PURE__*/ createContext(undefined);
const ChildrenContextProvider = /*#__PURE__*/ memo(ChildrenContext);
export const Children = ()=>use(ChildrenContext);
export const useElementsPromise_UNSTABLE = ()=>{
    const elementsPromise = use(ElementsContext);
    if (!elementsPromise) {
        throw new Error('Missing Root component');
    }
    return elementsPromise;
};
/**
 * Slot component
 * This is used under the Root component.
 * Slot id is the key of elements returned by the server.
 *
 * If the server returns this
 * ```
 *   { 'foo': <div>foo</div>, 'bar': <div>bar</div> }
 * ```
 * then you can use this component like this
 * ```
 *   <Root><Slot id="foo" /><Slot id="bar" /></Root>
 * ```
 */ export const Slot = ({ id, children })=>{
    const elementsPromise = useElementsPromise_UNSTABLE();
    const elements = use(elementsPromise);
    if (id in elements && elements[id] === undefined) {
        throw new Error('Element cannot be undefined, use null instead: ' + id);
    }
    const element = elements[id];
    const isValidElement = element !== undefined;
    if (!isValidElement) {
        throw new Error('Invalid element: ' + id);
    }
    return /*#__PURE__*/ _jsx(ChildrenContextProvider, {
        value: children,
        children: element
    });
};
/**
 * ServerRoot for SSR
 * This is not a public API.
 */ export const INTERNAL_ServerRoot = ({ elementsPromise, children })=>/*#__PURE__*/ _jsxs(ElementsContext, {
        value: elementsPromise,
        children: [
            DEFAULT_HTML_HEAD,
            children
        ]
    });

//# sourceMappingURL=client.js.map