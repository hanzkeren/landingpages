'use client';
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Component, createContext, startTransition, use, useCallback, useContext, useEffect, useRef, useState, useTransition } from 'react';
import { getErrorInfo } from '../lib/utils/custom-errors.js';
import { addBase, removeBase } from '../lib/utils/path.js';
import { Root, Slot, prefetchRsc, useElementsPromise_UNSTABLE as useElementsPromise, useEnhanceFetchRscInternal_UNSTABLE as useEnhanceFetchRscInternal, useRefetch } from '../minimal/client.js';
import { HAS404_ID, IS_STATIC_ID, ROUTE_ID, SKIP_HEADER, encodeRoutePath, encodeSliceId } from './common.js';
const normalizeRoutePath = (path)=>{
    path = removeBase(path, import.meta.env.WAKU_CONFIG_BASE_PATH);
    for (const suffix of [
        '/',
        '/index.html'
    ]){
        if (path.endsWith(suffix)) {
            return path.slice(0, -suffix.length) || '/';
        }
    }
    return path;
};
const parseRoute = (url)=>{
    const { pathname, searchParams, hash } = url;
    return {
        path: normalizeRoutePath(pathname),
        query: searchParams.toString(),
        hash
    };
};
const getHttpStatusFromMeta = ()=>{
    const httpStatusMeta = document.querySelector('meta[name="httpstatus"]');
    if (httpStatusMeta && 'content' in httpStatusMeta && typeof httpStatusMeta.content === 'string') {
        return httpStatusMeta.content;
    }
    return undefined;
};
const parseRouteFromLocation = ()=>{
    const httpStatus = getHttpStatusFromMeta();
    if (httpStatus === '404') {
        return {
            path: '/404',
            query: '',
            hash: ''
        };
    }
    return parseRoute(new URL(window.location.href));
};
const isAltClick = (event)=>event.button !== 0 || !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
let savedRscParams;
const createRscParams = (query)=>{
    if (savedRscParams && savedRscParams[0] === query) {
        return savedRscParams[1];
    }
    const rscParams = new URLSearchParams({
        query
    });
    savedRscParams = [
        query,
        rscParams
    ];
    return rscParams;
};
// This is an internal thing, not a public API
const RouterContext = /*#__PURE__*/ createContext(null);
export function useRouter() {
    const router = useContext(RouterContext);
    if (!router) {
        throw new Error('Missing Router');
    }
    const { route, changeRoute, prefetchRoute } = router;
    const push = useCallback(async (to, options)=>{
        to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);
        const url = new URL(to, window.location.href);
        const currentPath = window.location.pathname;
        const newPath = url.pathname !== currentPath;
        await changeRoute(parseRoute(url), {
            shouldScroll: options?.scroll ?? newPath
        });
        if (window.location.pathname === currentPath) {
            window.history.pushState({
                ...window.history.state,
                waku_new_path: newPath
            }, '', url);
        }
    }, [
        changeRoute
    ]);
    const replace = useCallback(async (to, options)=>{
        to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);
        const url = new URL(to, window.location.href);
        const currentPath = window.location.pathname;
        const newPath = url.pathname !== currentPath;
        await changeRoute(parseRoute(url), {
            shouldScroll: options?.scroll ?? newPath
        });
        if (window.location.pathname === currentPath) {
            window.history.replaceState(window.history.state, '', url);
        }
    }, [
        changeRoute
    ]);
    const reload = useCallback(async ()=>{
        const url = new URL(window.location.href);
        await changeRoute(parseRoute(url), {
            shouldScroll: true
        });
    }, [
        changeRoute
    ]);
    const back = useCallback(()=>{
        // FIXME is this correct?
        window.history.back();
    }, []);
    const forward = useCallback(()=>{
        // FIXME is this correct?
        window.history.forward();
    }, []);
    const prefetch = useCallback((to)=>{
        const url = new URL(to, window.location.href);
        prefetchRoute(parseRoute(url));
    }, [
        prefetchRoute
    ]);
    return {
        ...route,
        push,
        replace,
        reload,
        back,
        forward,
        prefetch,
        unstable_events: router.routeChangeEvents
    };
}
function useSharedRef(ref) {
    const managedRef = useRef(null);
    const handleRef = useCallback((node)=>{
        managedRef.current = node;
        const isRefCallback = typeof ref === 'function';
        let cleanup;
        if (isRefCallback) {
            cleanup = ref(node);
        } else if (ref) {
            // TODO is this a false positive?
            // eslint-disable-next-line react-hooks/immutability
            ref.current = node;
        }
        return ()=>{
            managedRef.current = null;
            if (isRefCallback) {
                if (cleanup) {
                    cleanup();
                } else {
                    ref(null);
                }
            } else if (ref) {
                ref.current = null;
            }
        };
    }, [
        ref
    ]);
    return [
        managedRef,
        handleRef
    ];
}
export function Link({ to, children, scroll, unstable_pending, unstable_notPending, unstable_prefetchOnEnter, unstable_prefetchOnView, unstable_startTransition, ref: refProp, ...props }) {
    to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);
    const router = useContext(RouterContext);
    const changeRoute = router ? router.changeRoute : ()=>{
        throw new Error('Missing Router');
    };
    const prefetchRoute = router ? router.prefetchRoute : ()=>{
        throw new Error('Missing Router');
    };
    const [isPending, startTransition] = useTransition();
    const startTransitionFn = unstable_startTransition || (unstable_pending || unstable_notPending) && startTransition || ((fn)=>fn());
    const [ref, setRef] = useSharedRef(refProp);
    useEffect(()=>{
        if (unstable_prefetchOnView && ref.current) {
            const observer = new IntersectionObserver((entries)=>{
                entries.forEach((entry)=>{
                    if (entry.isIntersecting) {
                        const url = new URL(to, window.location.href);
                        if (router && url.href !== window.location.href) {
                            const route = parseRoute(url);
                            router.prefetchRoute(route);
                        }
                    }
                });
            }, {
                threshold: 0.1
            });
            observer.observe(ref.current);
            return ()=>{
                observer.disconnect();
            };
        }
    }, [
        unstable_prefetchOnView,
        router,
        to,
        ref
    ]);
    const internalOnClick = ()=>{
        const url = new URL(to, window.location.href);
        if (url.href !== window.location.href) {
            const route = parseRoute(url);
            prefetchRoute(route);
            startTransitionFn(async ()=>{
                const currentPath = window.location.pathname;
                const newPath = url.pathname !== currentPath;
                try {
                    await changeRoute(route, {
                        shouldScroll: scroll ?? newPath,
                        unstable_startTransition: startTransitionFn
                    });
                } finally{
                    if (window.location.pathname === currentPath) {
                        // Update history if it wasn't already updated
                        window.history.pushState({
                            ...window.history.state,
                            waku_new_path: newPath
                        }, '', url);
                    }
                }
            });
        }
    };
    const onClick = (event)=>{
        if (props.onClick) {
            props.onClick(event);
        }
        if (!event.defaultPrevented && !isAltClick(event)) {
            event.preventDefault();
            internalOnClick();
        }
    };
    const onMouseEnter = unstable_prefetchOnEnter ? (event)=>{
        const url = new URL(to, window.location.href);
        if (url.href !== window.location.href) {
            const route = parseRoute(url);
            prefetchRoute(route);
        }
        props.onMouseEnter?.(event);
    } : props.onMouseEnter;
    const ele = /*#__PURE__*/ _jsx("a", {
        ...props,
        href: to,
        onClick: onClick,
        onMouseEnter: onMouseEnter,
        ref: setRef,
        children: children
    });
    if (isPending && unstable_pending !== undefined) {
        return /*#__PURE__*/ _jsxs(_Fragment, {
            children: [
                ele,
                unstable_pending
            ]
        });
    }
    if (!isPending && unstable_notPending !== undefined) {
        return /*#__PURE__*/ _jsxs(_Fragment, {
            children: [
                ele,
                unstable_notPending
            ]
        });
    }
    return ele;
}
const notAvailableInServer = (name)=>()=>{
        throw new Error(`${name} is not in the server`);
    };
function renderError(message) {
    return /*#__PURE__*/ _jsxs("html", {
        children: [
            /*#__PURE__*/ _jsx("head", {
                children: /*#__PURE__*/ _jsx("title", {
                    children: "Unhandled Error"
                })
            }),
            /*#__PURE__*/ _jsxs("body", {
                style: {
                    height: '100vh',
                    display: 'flex',
                    flexDirection: 'column',
                    placeContent: 'center',
                    placeItems: 'center',
                    fontSize: '16px',
                    margin: 0
                },
                children: [
                    /*#__PURE__*/ _jsx("h1", {
                        children: "Caught an unexpected error"
                    }),
                    /*#__PURE__*/ _jsxs("p", {
                        children: [
                            "Error: ",
                            message
                        ]
                    })
                ]
            })
        ]
    });
}
export class ErrorBoundary extends Component {
    constructor(props){
        super(props);
        this.state = {};
    }
    static getDerivedStateFromError(error) {
        return {
            error
        };
    }
    render() {
        if ('error' in this.state) {
            if (this.state.error instanceof Error) {
                return renderError(this.state.error.message);
            }
            return renderError(String(this.state.error));
        }
        return this.props.children;
    }
}
const NotFound = ({ has404, reset })=>{
    const router = useContext(RouterContext);
    if (!router) {
        throw new Error('Missing Router');
    }
    const { changeRoute } = router;
    useEffect(()=>{
        if (has404) {
            const url = new URL('/404', window.location.href);
            changeRoute(parseRoute(url), {
                shouldScroll: true
            }).then(()=>{
                // HACK: This timeout is required for canary-ci to work
                // FIXME: As we understand it, we should have a proper solution.
                setTimeout(()=>{
                    reset();
                }, 1);
            }).catch((err)=>{
                console.log('Error while navigating to 404:', err);
            });
        }
    }, [
        has404,
        reset,
        changeRoute
    ]);
    return has404 ? null : /*#__PURE__*/ _jsx("h1", {
        children: "Not Found"
    });
};
const Redirect = ({ error, to, reset, handledErrorSet })=>{
    const router = useContext(RouterContext);
    if (!router) {
        throw new Error('Missing Router');
    }
    const { changeRoute } = router;
    useEffect(()=>{
        // ensure single re-fetch per server redirection error on StrictMode
        // https://github.com/wakujs/waku/pull/1512
        if (handledErrorSet.has(error)) {
            return;
        }
        handledErrorSet.add(error);
        const url = new URL(to, window.location.href);
        // FIXME this condition seems too naive
        if (url.hostname !== window.location.hostname) {
            window.location.replace(to);
            return;
        }
        const currentPath = window.location.pathname;
        const newPath = url.pathname !== currentPath;
        changeRoute(parseRoute(url), {
            shouldScroll: newPath
        }).then(()=>{
            // FIXME: As we understand it, we should have a proper solution.
            setTimeout(()=>{
                reset();
            }, 1);
        }).catch((err)=>{
            console.log('Error while navigating to redirect:', err);
        }).finally(()=>{
            if (window.location.pathname === currentPath) {
                window.history.replaceState({
                    ...window.history.state,
                    waku_new_path: newPath
                }, '', url);
            }
        });
    }, [
        error,
        to,
        reset,
        changeRoute,
        handledErrorSet
    ]);
    return null;
};
class CustomErrorHandler extends Component {
    handledErrorSet = new WeakSet();
    constructor(props){
        super(props);
        this.state = {
            error: null
        };
        this.reset = this.reset.bind(this);
    }
    static getDerivedStateFromError(error) {
        return {
            error
        };
    }
    reset() {
        this.setState({
            error: null
        });
    }
    render() {
        const { error } = this.state;
        if (error !== null) {
            const info = getErrorInfo(error);
            if (info?.status === 404) {
                return /*#__PURE__*/ _jsx(NotFound, {
                    has404: this.props.has404,
                    reset: this.reset
                });
            }
            if (info?.location) {
                return /*#__PURE__*/ _jsx(Redirect, {
                    error: error,
                    to: info.location,
                    reset: this.reset,
                    handledErrorSet: this.handledErrorSet
                });
            }
            throw error;
        }
        return this.props.children;
    }
}
const ThrowError = ({ error })=>{
    throw error;
};
const getRouteSlotId = (path)=>'route:' + decodeURI(path);
const getSliceSlotId = (id)=>'slice:' + id;
export function Slice({ id, children, ...props }) {
    const router = useContext(RouterContext);
    if (!router) {
        throw new Error('Missing Router');
    }
    const { fetchingSlices } = router;
    const refetch = useRefetch();
    const slotId = getSliceSlotId(id);
    const elementsPromise = useElementsPromise();
    const elements = use(elementsPromise);
    const needsToFetchSlice = props.lazy && (!(slotId in elements) || // FIXME: hard-coded for now
    elements[IS_STATIC_ID + ':' + slotId] !== true);
    useEffect(()=>{
        // FIXME this works because of subtle timing behavior.
        if (needsToFetchSlice && !fetchingSlices.has(id)) {
            fetchingSlices.add(id);
            const rscPath = encodeSliceId(id);
            refetch(rscPath).catch((e)=>{
                console.error('Failed to fetch slice:', e);
            }).finally(()=>{
                fetchingSlices.delete(id);
            });
        }
    }, [
        fetchingSlices,
        refetch,
        id,
        needsToFetchSlice
    ]);
    if (props.lazy && !(slotId in elements)) {
        // FIXME the fallback doesn't show on refetch after the first one.
        return props.fallback;
    }
    return /*#__PURE__*/ _jsx(Slot, {
        id: slotId,
        children: children
    });
}
const handleScroll = ()=>{
    const { hash } = window.location;
    const { state } = window.history;
    const element = hash && document.getElementById(hash.slice(1));
    window.scrollTo({
        left: 0,
        top: element ? element.getBoundingClientRect().top + window.scrollY : 0,
        behavior: state?.waku_new_path ? 'instant' : 'auto'
    });
};
const InnerRouter = ({ initialRoute, httpStatus })=>{
    if (import.meta.hot) {
        const refetchRoute = ()=>{
            staticPathSetRef.current.clear();
            cachedIdSetRef.current.clear();
            const rscPath = encodeRoutePath(route.path);
            const rscParams = createRscParams(route.query);
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            refetch(rscPath, rscParams);
        };
        globalThis.__WAKU_RSC_RELOAD_LISTENERS__ ||= [];
        const index = globalThis.__WAKU_RSC_RELOAD_LISTENERS__.indexOf(globalThis.__WAKU_REFETCH_ROUTE__);
        if (index !== -1) {
            globalThis.__WAKU_RSC_RELOAD_LISTENERS__.splice(index, 1, refetchRoute);
        } else {
            globalThis.__WAKU_RSC_RELOAD_LISTENERS__.unshift(refetchRoute);
        }
        globalThis.__WAKU_REFETCH_ROUTE__ = refetchRoute;
    }
    const elementsPromise = useElementsPromise();
    const [has404, setHas404] = useState(false);
    const requestedRouteRef = useRef(initialRoute);
    const staticPathSetRef = useRef(new Set());
    const cachedIdSetRef = useRef(new Set());
    useEffect(()=>{
        elementsPromise.then((elements)=>{
            const { [ROUTE_ID]: routeData, [IS_STATIC_ID]: isStatic, [HAS404_ID]: has404FromElements, ...rest } = elements;
            if (has404FromElements) {
                setHas404(true);
            }
            if (routeData) {
                const [path, _query] = routeData;
                if (isStatic) {
                    staticPathSetRef.current.add(path);
                }
            }
            cachedIdSetRef.current = new Set(Object.keys(rest));
        }, ()=>{});
    }, [
        elementsPromise
    ]);
    const enhanceFetchRscInternal = useEnhanceFetchRscInternal();
    const locationListenersRef = useRef(new Set());
    const locationListeners = locationListenersRef.current;
    useEffect(()=>{
        const enhanceFetch = (fetchFn)=>(input, init = {})=>{
                const skipStr = JSON.stringify(Array.from(cachedIdSetRef.current));
                const headers = init.headers ||= {};
                if (Array.isArray(headers)) {
                    headers.push([
                        SKIP_HEADER,
                        skipStr
                    ]);
                } else {
                    headers[SKIP_HEADER] = skipStr;
                }
                return fetchFn(input, init);
            };
        return enhanceFetchRscInternal((fetchRscInternal)=>(rscPath, rscParams, prefetchOnly, fetchFn = fetch)=>{
                const enhancedFetch = enhanceFetch(fetchFn);
                const elementsPromise = fetchRscInternal(rscPath, rscParams, prefetchOnly, enhancedFetch);
                Promise.resolve(elementsPromise).then((elements = {})=>{
                    const { [ROUTE_ID]: routeData, [IS_STATIC_ID]: isStatic } = elements;
                    if (routeData) {
                        const [path, query] = routeData;
                        if (requestedRouteRef.current.path !== path || !isStatic && requestedRouteRef.current.query !== query) {
                            locationListeners.forEach((listener)=>listener(path, query));
                        }
                    }
                }).catch(()=>{});
                return elementsPromise;
            });
    }, [
        enhanceFetchRscInternal,
        locationListeners
    ]);
    const refetch = useRefetch();
    const [route, setRoute] = useState(()=>({
            // This is the first initialization of the route, and it has
            // to ignore the hash, because on server side there is none.
            // Otherwise there will be a hydration error.
            // The client side route, including the hash, will be updated in the effect below.
            ...initialRoute,
            hash: ''
        }));
    const routeChangeListenersRef = useRef(null);
    if (routeChangeListenersRef.current === null) {
        const listeners = {
            start: new Set(),
            complete: new Set()
        };
        const executeListeners = (eventType, eventRoute)=>{
            const eventListenersSet = listeners[eventType];
            if (!eventListenersSet.size) {
                return;
            }
            for (const listener of eventListenersSet){
                listener(eventRoute);
            }
        };
        const events = (()=>{
            const on = (event, handler)=>{
                listeners[event].add(handler);
            };
            const off = (event, handler)=>{
                listeners[event].delete(handler);
            };
            return {
                on,
                off
            };
        })();
        routeChangeListenersRef.current = [
            events,
            executeListeners
        ];
    }
    // Update the route post-load to include the current hash.
    useEffect(()=>{
        setRoute((prev)=>{
            if (prev.path === initialRoute.path && prev.query === initialRoute.query && prev.hash === initialRoute.hash) {
                return prev;
            }
            return initialRoute;
        });
    }, [
        initialRoute
    ]);
    const [routeChangeEvents, executeListeners] = routeChangeListenersRef.current;
    const [err, setErr] = useState(null);
    // FIXME this "refetching" hack doesn't seem ideal.
    const refetching = useRef(null);
    const changeRoute = useCallback(async (route, options)=>{
        requestedRouteRef.current = route;
        executeListeners('start', route);
        const startTransitionFn = options.unstable_startTransition || ((fn)=>fn());
        refetching.current = [];
        setErr(null);
        const { skipRefetch } = options || {};
        if (!staticPathSetRef.current.has(route.path) && !skipRefetch) {
            const rscPath = encodeRoutePath(route.path);
            const rscParams = createRscParams(route.query);
            try {
                await refetch(rscPath, rscParams);
            } catch (e) {
                refetching.current = null;
                setErr(e);
                throw e;
            }
        }
        startTransitionFn(()=>{
            if (options.shouldScroll) {
                handleScroll();
            }
            setRoute(route);
            refetching.current[0]?.();
            refetching.current = null;
            executeListeners('complete', route);
        });
    }, [
        executeListeners,
        refetch
    ]);
    const prefetchRoute = useCallback((route)=>{
        if (staticPathSetRef.current.has(route.path)) {
            return;
        }
        const rscPath = encodeRoutePath(route.path);
        const rscParams = createRscParams(route.query);
        prefetchRsc(rscPath, rscParams);
        globalThis.__WAKU_ROUTER_PREFETCH__?.(route.path);
    }, []);
    useEffect(()=>{
        const callback = ()=>{
            const route = parseRoute(new URL(window.location.href));
            changeRoute(route, {
                shouldScroll: true
            }).catch((err)=>{
                console.log('Error while navigating back:', err);
            });
        };
        window.addEventListener('popstate', callback);
        return ()=>{
            window.removeEventListener('popstate', callback);
        };
    }, [
        changeRoute
    ]);
    useEffect(()=>{
        const callback = (path, query)=>{
            const fn = ()=>{
                const url = new URL(window.location.href);
                url.pathname = path;
                url.search = query;
                url.hash = '';
                changeRoute(parseRoute(url), {
                    skipRefetch: true,
                    shouldScroll: false
                }).catch((err)=>{
                    console.log('Error while handling location listeners:', err);
                }).finally(()=>{
                    if (path !== '/404') {
                        window.history.pushState({
                            ...window.history.state,
                            waku_new_path: url.pathname !== window.location.pathname
                        }, '', url);
                    }
                });
            };
            if (refetching.current) {
                refetching.current.push(fn);
            } else {
                startTransition(fn);
            }
        };
        locationListeners.add(callback);
        return ()=>{
            locationListeners.delete(callback);
        };
    }, [
        changeRoute,
        locationListeners
    ]);
    const routeElement = err !== null ? /*#__PURE__*/ _jsx(ThrowError, {
        error: err
    }) : /*#__PURE__*/ _jsx(Slot, {
        id: getRouteSlotId(route.path)
    });
    const rootElement = /*#__PURE__*/ _jsxs(Slot, {
        id: "root",
        children: [
            /*#__PURE__*/ _jsx("meta", {
                name: "httpstatus",
                content: httpStatus
            }),
            /*#__PURE__*/ _jsx(CustomErrorHandler, {
                has404: has404,
                children: routeElement
            })
        ]
    });
    return /*#__PURE__*/ _jsx(RouterContext, {
        value: {
            route,
            changeRoute,
            prefetchRoute,
            routeChangeEvents,
            fetchingSlices: useRef(new Set()).current
        },
        children: rootElement
    });
};
export function Router({ initialRoute = parseRouteFromLocation() }) {
    const initialRscPath = encodeRoutePath(initialRoute.path);
    const initialRscParams = createRscParams(initialRoute.query);
    const httpStatus = getHttpStatusFromMeta();
    return /*#__PURE__*/ _jsx(Root, {
        initialRscPath: initialRscPath,
        initialRscParams: initialRscParams,
        children: /*#__PURE__*/ _jsx(InnerRouter, {
            initialRoute: initialRoute,
            httpStatus: httpStatus
        })
    });
}
const MOCK_ROUTE_CHANGE_LISTENER = {
    on: ()=>notAvailableInServer('routeChange:on'),
    off: ()=>notAvailableInServer('routeChange:off')
};
/**
 * ServerRouter for SSR
 * This is not a public API.
 */ export function INTERNAL_ServerRouter({ route, httpstatus }) {
    const routeElement = /*#__PURE__*/ _jsx(Slot, {
        id: getRouteSlotId(route.path)
    });
    const rootElement = /*#__PURE__*/ _jsxs(Slot, {
        id: "root",
        children: [
            /*#__PURE__*/ _jsx("meta", {
                name: "httpstatus",
                content: `${httpstatus}`
            }),
            routeElement
        ]
    });
    return /*#__PURE__*/ _jsx(_Fragment, {
        children: /*#__PURE__*/ _jsx(RouterContext, {
            value: {
                route,
                changeRoute: notAvailableInServer('changeRoute'),
                prefetchRoute: notAvailableInServer('prefetchRoute'),
                routeChangeEvents: MOCK_ROUTE_CHANGE_LISTENER,
                fetchingSlices: new Set()
            },
            children: rootElement
        })
    });
}

//# sourceMappingURL=client.js.map