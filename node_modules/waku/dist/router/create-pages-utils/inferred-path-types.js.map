{"version":3,"sources":["../../../src/router/create-pages-utils/inferred-path-types.ts"],"sourcesContent":["import type { RouteProps } from '../common.js';\nimport type { PathWithoutSlug } from '../create-pages.js';\nimport type { Join, Prettify, ReplaceAll, Split } from '../util-types.js';\n\ntype ReadOnlyStringTupleList = readonly (readonly string[])[];\n\ntype StaticSlugPage = {\n  path: string;\n  render: 'static';\n  staticPaths: readonly string[] | ReadOnlyStringTupleList;\n};\n\ntype DynamicPage = {\n  path: string;\n  render: 'dynamic';\n};\n\ntype IsPageWithSlug<Page extends AnyPage> = Page extends {\n  path: infer P;\n}\n  ? P extends PathWithoutSlug<P>\n    ? false\n    : true\n  : never;\n\n/** Used to replace a single slug param [mySlug] with a union of possible slugs 'foo' | 'bar' */\ntype ReplaceSlugSet<\n  Path extends string,\n  Slugs extends string,\n> = Slugs extends unknown ? ReplaceAll<Path, `[${string}]`, Slugs> : never;\n\n/**\n * This will replace slugs in the path with each entry to a string[][] passed to staticPaths.\n *\n * For example, if the path is `/foo/[...slug]` and the staticPaths is [['a', 'b'], ['c']],\n * the result will be `/foo/a/b` | `/foo/c`.\n *\n * And if the path is `/foo/[slug1]/[slug2]` and the staticPaths is [['a', 'b'], ['c', 'd']],\n * the result will be `/foo/a/b` | `/foo/c/d`.\n */\ntype ReplaceHelper<\n  SplitPath extends readonly string[],\n  StaticSlugs extends readonly string[],\n  // SlugCountArr is a counter for the number of slugs added to result so far\n  SlugCountArr extends null[] = [],\n  Result extends string[] = [],\n> = SplitPath extends [\n  infer PathPart extends string,\n  ...infer Rest extends string[],\n]\n  ? PathPart extends `[...${string}]`\n    ? [...Result, ...StaticSlugs] // Wildcard always comes last\n    : PathPart extends `[${string}]`\n      ? ReplaceHelper<\n          Rest,\n          StaticSlugs,\n          [...SlugCountArr, null],\n          [...Result, StaticSlugs[SlugCountArr['length']]]\n        >\n      : ReplaceHelper<Rest, StaticSlugs, SlugCountArr, [...Result, PathPart]>\n  : Result;\n\n/**\n * Entry point to ReplaceHelper that Splits the path to start and Joins the final result.\n * This also loops over each possible StaticPathSet for when staticPaths is a string[][].\n * The looping is done by `StaticPathSet extends unknown`.\n */\ntype ReplaceTupleStaticPaths<\n  Path extends string,\n  StaticPathSet extends readonly string[],\n> = StaticPathSet extends unknown\n  ? Join<ReplaceHelper<Split<Path, '/'>, StaticPathSet>, '/'>\n  : never;\n\n/** staticPaths could be a string or a string[][]. This type acts as an if else to handle each type of staticPaths. */\ntype CollectPathsForStaticSlugPage<Page extends StaticSlugPage> = Page extends {\n  path: infer Path extends string;\n  render: 'static';\n  staticPaths: infer StaticPaths extends\n    | readonly string[]\n    | ReadOnlyStringTupleList;\n}\n  ? StaticPaths extends readonly string[]\n    ? ReplaceSlugSet<Path, StaticPaths[number]>\n    : StaticPaths extends ReadOnlyStringTupleList\n      ? ReplaceTupleStaticPaths<Path, StaticPaths[number]>\n      : never\n  : never;\n\n/** Simply replace all slugs with any string for dynamic pages.*/\ntype CollectPathsForDynamicSlugPage<Page extends DynamicPage> = Page extends {\n  path: infer Path extends string;\n}\n  ? ReplaceAll<Path, `[${string}]`, string>\n  : never;\n\n/**\n * CollectPaths takes each page of type AnyPage and maps over them to get the paths for that page.\n *\n * You can consider this the entry point to each of the page => path mappings.\n *\n * - Pages with no slugs will return the path as is.\n * - Static pages with slugs will return the path with the slugs replaced with the staticPaths.\n * - Dynamic pages with slugs will return the path with the slugs replaced with any string.\n *   (e.g., `/[slug]` => `/${string}`)\n */\nexport type CollectPaths<EachPage extends AnyPage> = EachPage extends unknown\n  ? IsPageWithSlug<EachPage> extends true\n    ? EachPage extends StaticSlugPage\n      ? CollectPathsForStaticSlugPage<EachPage>\n      : EachPage extends DynamicPage\n        ? CollectPathsForDynamicSlugPage<EachPage>\n        : never\n    : EachPage['path']\n  : never;\n\n/** Generic type that represents any page. This is used to infer the return type of createPages. */\nexport type AnyPage = {\n  path: string;\n  render: 'static' | 'dynamic';\n  staticPaths?: readonly string[] | readonly (readonly string[])[];\n};\n\n/**\n * PathsForPages will take the response of createPages and return the paths for all user defined pages.\n *\n * @example\n * const pages = createPages(async ({ createPage }) => [\n *   createPage({\n *     render: 'static',\n *     path: '/foo',\n *     component: Foo,\n *   }),\n *   createPage({\n *     render: 'static',\n *     path: '/bar',\n *     component: Bar,\n *   }),\n * ]);\n *\n * type MyPaths = PathsForPages<typeof pages>;\n * // type MyPaths = '/foo' | '/bar';\n */\nexport type PathsForPages<\n  PagesResult extends { DO_NOT_USE_pages: AnyPage } | AnyPage,\n> = PagesResult extends { DO_NOT_USE_pages: AnyPage }\n  ? CollectPaths<PagesResult['DO_NOT_USE_pages']> extends never\n    ? string\n    : CollectPaths<PagesResult['DO_NOT_USE_pages']>\n  : PagesResult extends AnyPage\n    ? CollectPaths<PagesResult> extends never\n      ? string\n      : CollectPaths<PagesResult>\n    : never;\n\ntype _GetSlugs<\n  Route extends string,\n  SplitRoute extends string[] = Split<Route, '/'>,\n  Result extends string[] = [],\n> = SplitRoute extends []\n  ? Result\n  : SplitRoute extends [`${infer MaybeSlug}`, ...infer Rest extends string[]]\n    ? MaybeSlug extends `[${infer Slug}]`\n      ? _GetSlugs<Route, Rest, [...Result, Slug]>\n      : _GetSlugs<Route, Rest, Result>\n    : Result;\n\nexport type GetSlugs<Route extends string> = _GetSlugs<Route>;\n\n/** Paths with slugs as string literals */\nexport type PagePath<Config> = Config extends {\n  pages: { path: infer Path };\n}\n  ? Path\n  : never;\n\ntype IndividualSlugType<Slug extends string> = Slug extends `...${string}`\n  ? string[]\n  : string;\n\ntype CleanWildcard<Slug extends string> = Slug extends `...${infer Wildcard}`\n  ? Wildcard\n  : Slug;\n\ntype SlugTypes<Path extends string> =\n  GetSlugs<Path> extends string[]\n    ? {\n        [Slug in GetSlugs<Path>[number] as CleanWildcard<Slug>]: IndividualSlugType<Slug>;\n      }\n    : never;\n\nexport type PropsForPages<Path extends string> = Prettify<\n  Omit<RouteProps<ReplaceAll<Path, `[${string}]`, string>>, 'hash'> &\n    SlugTypes<Path>\n>;\n\ntype GetResponseType<Response extends { render: string }> =\n  string extends Response['render'] ? { render: 'dynamic' } : Response;\n\n/**\n * Helper used for generation of types with fs-router for\n * collecting the type of the getConfig function response and\n * falling back to {render: 'dynamic'} if inference fails.\n */\nexport type GetConfigResponse<\n  Fn extends () => Promise<{ render: string }> | { render: string },\n> =\n  ReturnType<Fn> extends { render: string }\n    ? GetResponseType<ReturnType<Fn>>\n    : GetResponseType<Awaited<ReturnType<Fn>>>;\n"],"names":[],"mappings":"AAuMA;;;;CAIC,GACD,WAK+C"}