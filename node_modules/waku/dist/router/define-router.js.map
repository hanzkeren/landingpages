{"version":3,"sources":["../../src/router/define-router.tsx"],"sourcesContent":["import type { ReactNode } from 'react';\nimport { createCustomError, getErrorInfo } from '../lib/utils/custom-errors.js';\nimport { getPathMapping } from '../lib/utils/path.js';\nimport type { PathSpec } from '../lib/utils/path.js';\nimport { base64ToStream, streamToBase64 } from '../lib/utils/stream.js';\nimport { createTaskRunner } from '../lib/utils/task-runner.js';\nimport { unstable_defineHandlers as defineHandlers } from '../minimal/server.js';\nimport { unstable_getContext as getContext } from '../server.js';\nimport { INTERNAL_ServerRouter } from './client.js';\nimport {\n  HAS404_ID,\n  IS_STATIC_ID,\n  ROUTE_ID,\n  SKIP_HEADER,\n  decodeRoutePath,\n  decodeSliceId,\n  encodeRoutePath,\n  encodeSliceId,\n} from './common.js';\n\nconst isStringArray = (x: unknown): x is string[] =>\n  Array.isArray(x) && x.every((y) => typeof y === 'string');\n\nconst parseRscParams = (\n  rscParams: unknown,\n): {\n  query: string;\n} => {\n  if (rscParams instanceof URLSearchParams) {\n    return { query: rscParams.get('query') || '' };\n  }\n  if (\n    typeof (rscParams as { query?: undefined } | undefined)?.query === 'string'\n  ) {\n    return { query: (rscParams as { query: string }).query };\n  }\n  return { query: '' };\n};\n\nconst RSC_PATH_SYMBOL = Symbol('RSC_PATH');\nconst RSC_PARAMS_SYMBOL = Symbol('RSC_PARAMS');\n\nconst setRscPath = (rscPath: string) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RSC_PATH_SYMBOL, unknown>)[\n      RSC_PATH_SYMBOL\n    ] = rscPath;\n  } catch {\n    // ignore\n  }\n};\n\nconst setRscParams = (rscParams: unknown) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RSC_PARAMS_SYMBOL, unknown>)[\n      RSC_PARAMS_SYMBOL\n    ] = rscParams;\n  } catch {\n    // ignore\n  }\n};\n\nexport function unstable_getRscPath(): string | undefined {\n  try {\n    const context = getContext();\n    return (context as unknown as Record<typeof RSC_PATH_SYMBOL, string>)[\n      RSC_PATH_SYMBOL\n    ];\n  } catch {\n    return undefined;\n  }\n}\n\nexport function unstable_getRscParams(): unknown {\n  try {\n    const context = getContext();\n    return (context as unknown as Record<typeof RSC_PARAMS_SYMBOL, unknown>)[\n      RSC_PARAMS_SYMBOL\n    ];\n  } catch {\n    return undefined;\n  }\n}\n\nconst RERENDER_SYMBOL = Symbol('RERENDER');\ntype Rerender = (rscPath: string, rscParams?: unknown) => void;\n\nconst setRerender = (rerender: Rerender) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RERENDER_SYMBOL, Rerender>)[\n      RERENDER_SYMBOL\n    ] = rerender;\n  } catch {\n    // ignore\n  }\n};\n\nconst getRerender = (): Rerender => {\n  const context = getContext();\n  return (context as unknown as Record<typeof RERENDER_SYMBOL, Rerender>)[\n    RERENDER_SYMBOL\n  ];\n};\n\nconst is404 = (pathSpec: PathSpec) =>\n  pathSpec.length === 1 &&\n  pathSpec[0]!.type === 'literal' &&\n  pathSpec[0]!.name === '404';\n\nconst pathSpec2pathname = (pathSpec: PathSpec) => {\n  if (pathSpec.some(({ type }) => type !== 'literal')) {\n    return undefined;\n  }\n  return '/' + pathSpec.map(({ name }) => name!).join('/');\n};\n\nconst htmlPath2pathname = (htmlPath: string): string =>\n  htmlPath === '/404' ? '404.html' : htmlPath + '/index.html';\n\nexport function unstable_rerenderRoute(pathname: string, query?: string) {\n  const rscPath = encodeRoutePath(pathname);\n  getRerender()(rscPath, query && new URLSearchParams({ query }));\n}\n\nexport function unstable_notFound(): never {\n  throw createCustomError('Not Found', { status: 404 });\n}\n\nexport function unstable_redirect(\n  location: string,\n  status: 303 | 307 | 308 = 307,\n): never {\n  throw createCustomError('Redirect', { status, location });\n}\n\ntype SlotId = string;\n\nconst ROOT_SLOT_ID = 'root';\nconst ROUTE_SLOT_ID_PREFIX = 'route:';\nconst SLICE_SLOT_ID_PREFIX = 'slice:';\n\nconst assertNonReservedSlotId = (slotId: SlotId) => {\n  if (\n    slotId === ROOT_SLOT_ID ||\n    slotId.startsWith(ROUTE_SLOT_ID_PREFIX) ||\n    slotId.startsWith(SLICE_SLOT_ID_PREFIX)\n  ) {\n    throw new Error('Element ID cannot be \"root\", \"route:*\" or \"slice:*\"');\n  }\n};\n\ntype RendererOption = { pathname: string; query: string | undefined };\n\ntype RouteConfig = {\n  type: 'route';\n  path: PathSpec;\n  isStatic: boolean;\n  pathPattern?: PathSpec;\n  rootElement: {\n    isStatic: boolean;\n    renderer: (option: RendererOption) => ReactNode;\n  };\n  routeElement: {\n    isStatic: boolean;\n    renderer: (option: RendererOption) => ReactNode;\n  };\n  elements: Record<\n    SlotId,\n    {\n      isStatic: boolean;\n      renderer: (option: RendererOption) => ReactNode;\n    }\n  >;\n  noSsr?: boolean;\n  slices?: string[];\n};\n\ntype ApiConfig = {\n  type: 'api';\n  path: PathSpec;\n  isStatic: boolean;\n  handler: (req: Request) => Promise<Response>;\n};\n\ntype SliceConfig = {\n  type: 'slice';\n  id: string;\n  isStatic: boolean;\n  renderer: () => Promise<ReactNode>;\n};\n\nexport function unstable_defineRouter(fns: {\n  getConfigs: () => Promise<Iterable<RouteConfig | ApiConfig | SliceConfig>>;\n}) {\n  // This is an internal type for caching\n  type MyConfig = {\n    configs: (RouteConfig | ApiConfig | SliceConfig)[];\n    has404: boolean;\n  };\n\n  let cachedMyConfig: MyConfig | undefined;\n  const getMyConfig = async (): Promise<MyConfig> => {\n    if (!cachedMyConfig) {\n      const configs = Array.from(await fns.getConfigs());\n      let has404 = false;\n      configs.forEach((item) => {\n        if (item.type === 'route') {\n          Object.keys(item.elements).forEach(assertNonReservedSlotId);\n          if (!has404 && is404(item.path)) {\n            has404 = true;\n          }\n        }\n      });\n      cachedMyConfig = { configs, has404 };\n    }\n    return cachedMyConfig;\n  };\n\n  const getPathConfigItem = async (pathname: string) => {\n    const myConfig = await getMyConfig();\n    const found = myConfig.configs.find(\n      (item): item is typeof item & { type: 'route' | 'api' } =>\n        (item.type === 'route' || item.type === 'api') &&\n        !!getPathMapping(item.path, pathname),\n    );\n    return found;\n  };\n\n  const getSliceElement = async (\n    sliceConfig: {\n      id: string;\n      isStatic: boolean;\n      renderer: () => Promise<ReactNode>;\n    },\n    getCachedElement: (id: SlotId) => Promise<ReactNode> | undefined,\n    setCachedElement: (id: SlotId, element: ReactNode) => Promise<ReactNode>,\n  ): Promise<ReactNode> => {\n    const id = SLICE_SLOT_ID_PREFIX + sliceConfig.id;\n    const cached = getCachedElement(id);\n    if (cached) {\n      return cached;\n    }\n    let element = await sliceConfig.renderer();\n    if (sliceConfig.isStatic) {\n      element = await setCachedElement(id, element);\n    }\n    return element;\n  };\n\n  const getEntriesForRoute = async (\n    rscPath: string,\n    rscParams: unknown,\n    headers: Readonly<Record<string, string>>,\n    getCachedElement: (id: SlotId) => Promise<ReactNode> | undefined,\n    setCachedElement: (id: SlotId, element: ReactNode) => Promise<ReactNode>,\n  ) => {\n    setRscPath(rscPath);\n    setRscParams(rscParams);\n    const pathname = decodeRoutePath(rscPath);\n    const pathConfigItem = await getPathConfigItem(pathname);\n    if (pathConfigItem?.type !== 'route') {\n      return null;\n    }\n    let skipParam: unknown;\n    try {\n      skipParam = JSON.parse(headers[SKIP_HEADER.toLowerCase()] || '');\n    } catch {\n      // ignore\n    }\n    const skipIdSet = new Set(isStringArray(skipParam) ? skipParam : []);\n    const { query } = parseRscParams(rscParams);\n    const decodedPathname = decodeURI(pathname);\n    const routeId = ROUTE_SLOT_ID_PREFIX + decodedPathname;\n    const option: RendererOption = {\n      pathname: decodedPathname,\n      query: pathConfigItem.isStatic ? undefined : query,\n    };\n    const myConfig = await getMyConfig();\n    const slices = pathConfigItem.slices || [];\n    const sliceConfigMap = new Map<\n      string,\n      { id: string; isStatic: boolean; renderer: () => Promise<ReactNode> }\n    >();\n    slices.forEach((sliceId) => {\n      const sliceConfig = myConfig.configs.find(\n        (item): item is typeof item & { type: 'slice' } =>\n          item.type === 'slice' && item.id === sliceId,\n      );\n      if (sliceConfig) {\n        sliceConfigMap.set(sliceId, sliceConfig);\n      }\n    });\n    const entries: Record<SlotId, unknown> = {};\n    await Promise.all([\n      (async () => {\n        if (!pathConfigItem.rootElement.isStatic) {\n          entries[ROOT_SLOT_ID] = pathConfigItem.rootElement.renderer(option);\n        } else if (!skipIdSet.has(ROOT_SLOT_ID)) {\n          const cached = getCachedElement(ROOT_SLOT_ID);\n          entries[ROOT_SLOT_ID] = cached\n            ? await cached\n            : await setCachedElement(\n                ROOT_SLOT_ID,\n                pathConfigItem.rootElement.renderer(option),\n              );\n        }\n      })(),\n      (async () => {\n        if (!pathConfigItem.routeElement.isStatic) {\n          entries[routeId] = pathConfigItem.routeElement.renderer(option);\n        } else if (!skipIdSet.has(routeId)) {\n          const cached = getCachedElement(routeId);\n          entries[routeId] = cached\n            ? await cached\n            : await setCachedElement(\n                routeId,\n                pathConfigItem.routeElement.renderer(option),\n              );\n        }\n      })(),\n      ...Object.entries(pathConfigItem.elements).map(\n        async ([id, { isStatic }]) => {\n          const renderer = pathConfigItem.elements[id]?.renderer;\n          if (!isStatic) {\n            entries[id] = renderer?.(option);\n          } else if (!skipIdSet.has(id)) {\n            const cached = getCachedElement(id);\n            entries[id] = cached\n              ? await cached\n              : await setCachedElement(id, renderer?.(option));\n          }\n        },\n      ),\n      ...slices.map(async (sliceId) => {\n        const id = SLICE_SLOT_ID_PREFIX + sliceId;\n        const sliceConfig = sliceConfigMap.get(sliceId);\n        if (!sliceConfig) {\n          throw new Error(`Slice not found: ${sliceId}`);\n        }\n        if (sliceConfig.isStatic && skipIdSet.has(id)) {\n          return null;\n        }\n        const sliceElement = await getSliceElement(\n          sliceConfig,\n          getCachedElement,\n          setCachedElement,\n        );\n        entries[id] = sliceElement;\n      }),\n    ]);\n    entries[ROUTE_ID] = [decodedPathname, query];\n    entries[IS_STATIC_ID] = pathConfigItem.isStatic;\n    sliceConfigMap.forEach((sliceConfig, sliceId) => {\n      if (sliceConfig.isStatic) {\n        // FIXME: hard-coded for now\n        entries[IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + sliceId] = true;\n      }\n    });\n    if (myConfig.has404) {\n      entries[HAS404_ID] = true;\n    }\n    return entries;\n  };\n\n  type HandleRequest = Parameters<typeof defineHandlers>[0]['handleRequest'];\n  type HandleBuild = Parameters<typeof defineHandlers>[0]['handleBuild'];\n\n  const cachedElementsForRequest = new Map<SlotId, Promise<ReactNode>>();\n  let cachedElementsForRequestInitialized = false;\n  const handleRequest: HandleRequest = async (\n    input,\n    { renderRsc, parseRsc, renderHtml, loadBuildMetadata },\n  ): Promise<ReadableStream | Response | 'fallback' | null | undefined> => {\n    const getCachedElement = (id: SlotId) => cachedElementsForRequest.get(id);\n    const setCachedElement = (id: SlotId, element: ReactNode) => {\n      const cached = cachedElementsForRequest.get(id);\n      if (cached) {\n        return cached;\n      }\n      const copied = renderRsc({ [id]: element }).then((rscStream) =>\n        parseRsc(rscStream).then((parsed) => parsed[id]),\n      ) as Promise<ReactNode>;\n      cachedElementsForRequest.set(id, copied);\n      return copied;\n    };\n    if (!cachedElementsForRequestInitialized) {\n      cachedElementsForRequestInitialized = true;\n      const cachedElementsMetadata = await loadBuildMetadata(\n        'defineRouter:cachedElements',\n      );\n      if (cachedElementsMetadata) {\n        Object.entries(JSON.parse(cachedElementsMetadata)).forEach(\n          ([id, str]) => {\n            cachedElementsForRequest.set(\n              id,\n              parseRsc(base64ToStream(str as string)).then(\n                (parsed) => parsed[id],\n              ) as Promise<ReactNode>,\n            );\n          },\n        );\n      }\n    }\n    const pathConfigItem = await getPathConfigItem(input.pathname);\n    if (pathConfigItem?.type === 'api') {\n      const url = new URL(input.req.url);\n      url.pathname = input.pathname;\n      const req = new Request(url, input.req);\n      return pathConfigItem.handler(req);\n    }\n    const url = new URL(input.req.url);\n    const headers = Object.fromEntries(input.req.headers.entries());\n    if (input.type === 'component') {\n      const sliceId = decodeSliceId(input.rscPath);\n      if (sliceId !== null) {\n        // LIMITATION: This is a signle slice request.\n        // Ideally, we should be able to respond with multiple slices in one request.\n        const sliceConfig = await getMyConfig().then((myConfig) =>\n          myConfig.configs.find(\n            (item): item is typeof item & { type: 'slice' } =>\n              item.type === 'slice' && item.id === sliceId,\n          ),\n        );\n        if (!sliceConfig) {\n          return null;\n        }\n        const sliceElement = await getSliceElement(\n          sliceConfig,\n          getCachedElement,\n          setCachedElement,\n        );\n        return renderRsc({\n          [SLICE_SLOT_ID_PREFIX + sliceId]: sliceElement,\n          ...(sliceConfig.isStatic\n            ? {\n                // FIXME: hard-coded for now\n                [IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + sliceId]: true,\n              }\n            : {}),\n        });\n      }\n      const entries = await getEntriesForRoute(\n        input.rscPath,\n        input.rscParams,\n        headers,\n        getCachedElement,\n        setCachedElement,\n      );\n      if (!entries) {\n        return null;\n      }\n      return renderRsc(entries);\n    }\n    if (input.type === 'function') {\n      let elementsPromise: Promise<Record<string, unknown>> = Promise.resolve(\n        {},\n      );\n      let rendered = false;\n      const rerender = (rscPath: string, rscParams?: unknown) => {\n        if (rendered) {\n          throw new Error('already rendered');\n        }\n        elementsPromise = Promise.all([\n          elementsPromise,\n          getEntriesForRoute(\n            rscPath,\n            rscParams,\n            headers,\n            getCachedElement,\n            setCachedElement,\n          ),\n        ]).then(([oldElements, newElements]) => {\n          if (newElements === null) {\n            console.warn('getEntries returned null');\n          }\n          return {\n            ...oldElements,\n            ...newElements,\n          };\n        });\n      };\n      setRerender(rerender);\n      try {\n        const value = await input.fn(...input.args);\n        return renderRsc({ ...(await elementsPromise), _value: value });\n      } catch (e) {\n        const info = getErrorInfo(e);\n        if (info?.location) {\n          const rscPath = encodeRoutePath(info.location);\n          const entries = await getEntriesForRoute(\n            rscPath,\n            undefined,\n            headers,\n            getCachedElement,\n            setCachedElement,\n          );\n          if (!entries) {\n            unstable_notFound();\n          }\n          return renderRsc(entries);\n        }\n        throw e;\n      } finally {\n        rendered = true;\n      }\n    }\n    if (input.type === 'action' || input.type === 'custom') {\n      const renderIt = async (\n        pathname: string,\n        query: string,\n        httpstatus = 200,\n      ) => {\n        const rscPath = encodeRoutePath(pathname);\n        const rscParams = new URLSearchParams({ query });\n        const entries = await getEntriesForRoute(\n          rscPath,\n          rscParams,\n          headers,\n          getCachedElement,\n          setCachedElement,\n        );\n        if (!entries) {\n          return null;\n        }\n        const html = (\n          <INTERNAL_ServerRouter\n            route={{ path: pathname, query, hash: '' }}\n            httpstatus={httpstatus}\n          />\n        );\n        const actionResult =\n          input.type === 'action' ? await input.fn() : undefined;\n        return renderHtml(await renderRsc(entries), html, {\n          rscPath,\n          actionResult,\n          status: httpstatus,\n        });\n      };\n      const query = url.searchParams.toString();\n      if (pathConfigItem?.type === 'route' && pathConfigItem.noSsr) {\n        return 'fallback';\n      }\n      try {\n        if (pathConfigItem) {\n          return await renderIt(input.pathname, query);\n        }\n      } catch (e) {\n        const info = getErrorInfo(e);\n        if (info?.status !== 404) {\n          throw e;\n        }\n      }\n      if ((await getMyConfig()).has404) {\n        return renderIt('/404', '', 404);\n      } else {\n        return null;\n      }\n    }\n  };\n\n  const handleBuild: HandleBuild = async ({\n    renderRsc,\n    parseRsc,\n    renderHtml,\n    rscPath2pathname,\n    saveBuildMetadata,\n    withRequest,\n    generateFile,\n    generateDefaultHtml,\n  }) => {\n    const myConfig = await getMyConfig();\n    const cachedElementsForBuild = new Map<SlotId, Promise<ReactNode>>();\n    const serializedCachedElements = new Map<SlotId, string>();\n    const getCachedElement = (id: SlotId) => cachedElementsForBuild.get(id);\n    const setCachedElement = async (id: SlotId, element: ReactNode) => {\n      const cached = cachedElementsForBuild.get(id);\n      if (cached) {\n        return cached;\n      }\n      const teedStream = renderRsc({ [id]: element }).then((rscStream) =>\n        rscStream.tee(),\n      );\n      const stream1 = teedStream.then(([s1]) => s1);\n      const stream2 = teedStream.then(([, s2]) => s2);\n      const copied = stream1.then(\n        (rscStream) =>\n          parseRsc(rscStream).then(\n            (parsed) => parsed[id],\n          ) as Promise<ReactNode>,\n      );\n      cachedElementsForBuild.set(id, copied);\n      serializedCachedElements.set(id, await streamToBase64(await stream2));\n      return copied;\n    };\n\n    // hard-coded concurrency limit\n    const { runTask, waitForTasks } = createTaskRunner(500);\n\n    // static api\n    for (const item of myConfig.configs) {\n      if (item.type !== 'api') {\n        continue;\n      }\n      if (!item.isStatic) {\n        continue;\n      }\n      const pathname = pathSpec2pathname(item.path);\n      if (!pathname) {\n        continue;\n      }\n      const req = new Request(new URL(pathname, 'http://localhost:3000'));\n      runTask(async () => {\n        await withRequest(req, async () => {\n          const res = await item.handler(req);\n          await generateFile(pathname, res.body || '');\n        });\n      });\n    }\n\n    // static route\n    for (const item of myConfig.configs) {\n      if (item.type !== 'route') {\n        continue;\n      }\n      if (!item.isStatic) {\n        continue;\n      }\n      const pathname = pathSpec2pathname(item.path);\n      if (!pathname) {\n        continue;\n      }\n      const rscPath = encodeRoutePath(pathname);\n      const req = new Request(new URL(pathname, 'http://localhost:3000'));\n      runTask(async () => {\n        await withRequest(req, async () => {\n          const entries = await getEntriesForRoute(\n            rscPath,\n            undefined,\n            {},\n            getCachedElement,\n            setCachedElement,\n          );\n          if (!entries) {\n            return;\n          }\n          for (const id of Object.keys(entries)) {\n            const cached = getCachedElement(id);\n            entries[id] = cached ? await cached : entries[id];\n          }\n          const stream = await renderRsc(entries);\n          const [stream1, stream2] = stream.tee();\n          await generateFile(rscPath2pathname(rscPath), stream1);\n          const html = (\n            <INTERNAL_ServerRouter\n              route={{ path: pathname, query: '', hash: '' }}\n              httpstatus={is404(item.path) ? 404 : 200}\n            />\n          );\n          const res = await renderHtml(stream2, html, { rscPath });\n          await generateFile(htmlPath2pathname(pathname), res.body || '');\n        });\n      });\n    }\n\n    // default html\n    for (const item of myConfig.configs) {\n      if (item.type !== 'route') {\n        continue;\n      }\n      if (item.noSsr) {\n        const pathname = pathSpec2pathname(item.path);\n        if (!pathname) {\n          throw new Error('Pathname is required for noSsr routes on build');\n        }\n        runTask(async () => {\n          await generateDefaultHtml(htmlPath2pathname(pathname));\n        });\n      }\n    }\n\n    // static slice\n    for (const item of myConfig.configs) {\n      if (item.type !== 'slice') {\n        continue;\n      }\n      if (!item.isStatic) {\n        continue;\n      }\n      const rscPath = encodeSliceId(item.id);\n      // dummy req for slice which is not determined at build time\n      const req = new Request(new URL('http://localhost:3000'));\n      runTask(async () => {\n        await withRequest(req, async () => {\n          const sliceElement = await getSliceElement(\n            item,\n            getCachedElement,\n            setCachedElement,\n          );\n          const body = await renderRsc({\n            [SLICE_SLOT_ID_PREFIX + item.id]: sliceElement,\n            // FIXME: hard-coded for now\n            [IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + item.id]: true,\n          });\n          await generateFile(rscPath2pathname(rscPath), body);\n        });\n      });\n    }\n\n    await waitForTasks();\n\n    // TODO should we save serialized cached elements separately?\n    await saveBuildMetadata(\n      'defineRouter:cachedElements',\n      JSON.stringify(Object.fromEntries(serializedCachedElements)),\n    );\n  };\n\n  return Object.assign(defineHandlers({ handleRequest, handleBuild }), {\n    unstable_getRouterConfigs: () => getMyConfig().then((c) => c.configs),\n  });\n}\n"],"names":["createCustomError","getErrorInfo","getPathMapping","base64ToStream","streamToBase64","createTaskRunner","unstable_defineHandlers","defineHandlers","unstable_getContext","getContext","INTERNAL_ServerRouter","HAS404_ID","IS_STATIC_ID","ROUTE_ID","SKIP_HEADER","decodeRoutePath","decodeSliceId","encodeRoutePath","encodeSliceId","isStringArray","x","Array","isArray","every","y","parseRscParams","rscParams","URLSearchParams","query","get","RSC_PATH_SYMBOL","Symbol","RSC_PARAMS_SYMBOL","setRscPath","rscPath","context","setRscParams","unstable_getRscPath","undefined","unstable_getRscParams","RERENDER_SYMBOL","setRerender","rerender","getRerender","is404","pathSpec","length","type","name","pathSpec2pathname","some","map","join","htmlPath2pathname","htmlPath","unstable_rerenderRoute","pathname","unstable_notFound","status","unstable_redirect","location","ROOT_SLOT_ID","ROUTE_SLOT_ID_PREFIX","SLICE_SLOT_ID_PREFIX","assertNonReservedSlotId","slotId","startsWith","Error","unstable_defineRouter","fns","cachedMyConfig","getMyConfig","configs","from","getConfigs","has404","forEach","item","Object","keys","elements","path","getPathConfigItem","myConfig","found","find","getSliceElement","sliceConfig","getCachedElement","setCachedElement","id","cached","element","renderer","isStatic","getEntriesForRoute","headers","pathConfigItem","skipParam","JSON","parse","toLowerCase","skipIdSet","Set","decodedPathname","decodeURI","routeId","option","slices","sliceConfigMap","Map","sliceId","set","entries","Promise","all","rootElement","has","routeElement","sliceElement","cachedElementsForRequest","cachedElementsForRequestInitialized","handleRequest","input","renderRsc","parseRsc","renderHtml","loadBuildMetadata","copied","then","rscStream","parsed","cachedElementsMetadata","str","url","URL","req","Request","handler","fromEntries","elementsPromise","resolve","rendered","oldElements","newElements","console","warn","value","fn","args","_value","e","info","renderIt","httpstatus","html","route","hash","actionResult","searchParams","toString","noSsr","handleBuild","rscPath2pathname","saveBuildMetadata","withRequest","generateFile","generateDefaultHtml","cachedElementsForBuild","serializedCachedElements","teedStream","tee","stream1","s1","stream2","s2","runTask","waitForTasks","res","body","stream","stringify","assign","unstable_getRouterConfigs","c"],"mappings":";AACA,SAASA,iBAAiB,EAAEC,YAAY,QAAQ,gCAAgC;AAChF,SAASC,cAAc,QAAQ,uBAAuB;AAEtD,SAASC,cAAc,EAAEC,cAAc,QAAQ,yBAAyB;AACxE,SAASC,gBAAgB,QAAQ,8BAA8B;AAC/D,SAASC,2BAA2BC,cAAc,QAAQ,uBAAuB;AACjF,SAASC,uBAAuBC,UAAU,QAAQ,eAAe;AACjE,SAASC,qBAAqB,QAAQ,cAAc;AACpD,SACEC,SAAS,EACTC,YAAY,EACZC,QAAQ,EACRC,WAAW,EACXC,eAAe,EACfC,aAAa,EACbC,eAAe,EACfC,aAAa,QACR,cAAc;AAErB,MAAMC,gBAAgB,CAACC,IACrBC,MAAMC,OAAO,CAACF,MAAMA,EAAEG,KAAK,CAAC,CAACC,IAAM,OAAOA,MAAM;AAElD,MAAMC,iBAAiB,CACrBC;IAIA,IAAIA,qBAAqBC,iBAAiB;QACxC,OAAO;YAAEC,OAAOF,UAAUG,GAAG,CAAC,YAAY;QAAG;IAC/C;IACA,IACE,OAAQH,WAAiDE,UAAU,UACnE;QACA,OAAO;YAAEA,OAAO,AAACF,UAAgCE,KAAK;QAAC;IACzD;IACA,OAAO;QAAEA,OAAO;IAAG;AACrB;AAEA,MAAME,kBAAkBC,OAAO;AAC/B,MAAMC,oBAAoBD,OAAO;AAEjC,MAAME,aAAa,CAACC;IAClB,IAAI;QACF,MAAMC,UAAU1B;QACf0B,OAA8D,CAC7DL,gBACD,GAAGI;IACN,EAAE,OAAM;IACN,SAAS;IACX;AACF;AAEA,MAAME,eAAe,CAACV;IACpB,IAAI;QACF,MAAMS,UAAU1B;QACf0B,OAAgE,CAC/DH,kBACD,GAAGN;IACN,EAAE,OAAM;IACN,SAAS;IACX;AACF;AAEA,OAAO,SAASW;IACd,IAAI;QACF,MAAMF,UAAU1B;QAChB,OAAO,AAAC0B,OAA6D,CACnEL,gBACD;IACH,EAAE,OAAM;QACN,OAAOQ;IACT;AACF;AAEA,OAAO,SAASC;IACd,IAAI;QACF,MAAMJ,UAAU1B;QAChB,OAAO,AAAC0B,OAAgE,CACtEH,kBACD;IACH,EAAE,OAAM;QACN,OAAOM;IACT;AACF;AAEA,MAAME,kBAAkBT,OAAO;AAG/B,MAAMU,cAAc,CAACC;IACnB,IAAI;QACF,MAAMP,UAAU1B;QACf0B,OAA+D,CAC9DK,gBACD,GAAGE;IACN,EAAE,OAAM;IACN,SAAS;IACX;AACF;AAEA,MAAMC,cAAc;IAClB,MAAMR,UAAU1B;IAChB,OAAO,AAAC0B,OAA+D,CACrEK,gBACD;AACH;AAEA,MAAMI,QAAQ,CAACC,WACbA,SAASC,MAAM,KAAK,KACpBD,QAAQ,CAAC,EAAE,CAAEE,IAAI,KAAK,aACtBF,QAAQ,CAAC,EAAE,CAAEG,IAAI,KAAK;AAExB,MAAMC,oBAAoB,CAACJ;IACzB,IAAIA,SAASK,IAAI,CAAC,CAAC,EAAEH,IAAI,EAAE,GAAKA,SAAS,YAAY;QACnD,OAAOT;IACT;IACA,OAAO,MAAMO,SAASM,GAAG,CAAC,CAAC,EAAEH,IAAI,EAAE,GAAKA,MAAOI,IAAI,CAAC;AACtD;AAEA,MAAMC,oBAAoB,CAACC,WACzBA,aAAa,SAAS,aAAaA,WAAW;AAEhD,OAAO,SAASC,uBAAuBC,QAAgB,EAAE5B,KAAc;IACrE,MAAMM,UAAUjB,gBAAgBuC;IAChCb,cAAcT,SAASN,SAAS,IAAID,gBAAgB;QAAEC;IAAM;AAC9D;AAEA,OAAO,SAAS6B;IACd,MAAMzD,kBAAkB,aAAa;QAAE0D,QAAQ;IAAI;AACrD;AAEA,OAAO,SAASC,kBACdC,QAAgB,EAChBF,SAA0B,GAAG;IAE7B,MAAM1D,kBAAkB,YAAY;QAAE0D;QAAQE;IAAS;AACzD;AAIA,MAAMC,eAAe;AACrB,MAAMC,uBAAuB;AAC7B,MAAMC,uBAAuB;AAE7B,MAAMC,0BAA0B,CAACC;IAC/B,IACEA,WAAWJ,gBACXI,OAAOC,UAAU,CAACJ,yBAClBG,OAAOC,UAAU,CAACH,uBAClB;QACA,MAAM,IAAII,MAAM;IAClB;AACF;AA0CA,OAAO,SAASC,sBAAsBC,GAErC;IAOC,IAAIC;IACJ,MAAMC,cAAc;QAClB,IAAI,CAACD,gBAAgB;YACnB,MAAME,UAAUnD,MAAMoD,IAAI,CAAC,MAAMJ,IAAIK,UAAU;YAC/C,IAAIC,SAAS;YACbH,QAAQI,OAAO,CAAC,CAACC;gBACf,IAAIA,KAAK9B,IAAI,KAAK,SAAS;oBACzB+B,OAAOC,IAAI,CAACF,KAAKG,QAAQ,EAAEJ,OAAO,CAACZ;oBACnC,IAAI,CAACW,UAAU/B,MAAMiC,KAAKI,IAAI,GAAG;wBAC/BN,SAAS;oBACX;gBACF;YACF;YACAL,iBAAiB;gBAAEE;gBAASG;YAAO;QACrC;QACA,OAAOL;IACT;IAEA,MAAMY,oBAAoB,OAAO1B;QAC/B,MAAM2B,WAAW,MAAMZ;QACvB,MAAMa,QAAQD,SAASX,OAAO,CAACa,IAAI,CACjC,CAACR,OACC,AAACA,CAAAA,KAAK9B,IAAI,KAAK,WAAW8B,KAAK9B,IAAI,KAAK,KAAI,KAC5C,CAAC,CAAC7C,eAAe2E,KAAKI,IAAI,EAAEzB;QAEhC,OAAO4B;IACT;IAEA,MAAME,kBAAkB,OACtBC,aAKAC,kBACAC;QAEA,MAAMC,KAAK3B,uBAAuBwB,YAAYG,EAAE;QAChD,MAAMC,SAASH,iBAAiBE;QAChC,IAAIC,QAAQ;YACV,OAAOA;QACT;QACA,IAAIC,UAAU,MAAML,YAAYM,QAAQ;QACxC,IAAIN,YAAYO,QAAQ,EAAE;YACxBF,UAAU,MAAMH,iBAAiBC,IAAIE;QACvC;QACA,OAAOA;IACT;IAEA,MAAMG,qBAAqB,OACzB7D,SACAR,WACAsE,SACAR,kBACAC;QAEAxD,WAAWC;QACXE,aAAaV;QACb,MAAM8B,WAAWzC,gBAAgBmB;QACjC,MAAM+D,iBAAiB,MAAMf,kBAAkB1B;QAC/C,IAAIyC,gBAAgBlD,SAAS,SAAS;YACpC,OAAO;QACT;QACA,IAAImD;QACJ,IAAI;YACFA,YAAYC,KAAKC,KAAK,CAACJ,OAAO,CAAClF,YAAYuF,WAAW,GAAG,IAAI;QAC/D,EAAE,OAAM;QACN,SAAS;QACX;QACA,MAAMC,YAAY,IAAIC,IAAIpF,cAAc+E,aAAaA,YAAY,EAAE;QACnE,MAAM,EAAEtE,KAAK,EAAE,GAAGH,eAAeC;QACjC,MAAM8E,kBAAkBC,UAAUjD;QAClC,MAAMkD,UAAU5C,uBAAuB0C;QACvC,MAAMG,SAAyB;YAC7BnD,UAAUgD;YACV5E,OAAOqE,eAAeH,QAAQ,GAAGxD,YAAYV;QAC/C;QACA,MAAMuD,WAAW,MAAMZ;QACvB,MAAMqC,SAASX,eAAeW,MAAM,IAAI,EAAE;QAC1C,MAAMC,iBAAiB,IAAIC;QAI3BF,OAAOhC,OAAO,CAAC,CAACmC;YACd,MAAMxB,cAAcJ,SAASX,OAAO,CAACa,IAAI,CACvC,CAACR,OACCA,KAAK9B,IAAI,KAAK,WAAW8B,KAAKa,EAAE,KAAKqB;YAEzC,IAAIxB,aAAa;gBACfsB,eAAeG,GAAG,CAACD,SAASxB;YAC9B;QACF;QACA,MAAM0B,UAAmC,CAAC;QAC1C,MAAMC,QAAQC,GAAG,CAAC;YACf,CAAA;gBACC,IAAI,CAAClB,eAAemB,WAAW,CAACtB,QAAQ,EAAE;oBACxCmB,OAAO,CAACpD,aAAa,GAAGoC,eAAemB,WAAW,CAACvB,QAAQ,CAACc;gBAC9D,OAAO,IAAI,CAACL,UAAUe,GAAG,CAACxD,eAAe;oBACvC,MAAM8B,SAASH,iBAAiB3B;oBAChCoD,OAAO,CAACpD,aAAa,GAAG8B,SACpB,MAAMA,SACN,MAAMF,iBACJ5B,cACAoC,eAAemB,WAAW,CAACvB,QAAQ,CAACc;gBAE5C;YACF,CAAA;YACC,CAAA;gBACC,IAAI,CAACV,eAAeqB,YAAY,CAACxB,QAAQ,EAAE;oBACzCmB,OAAO,CAACP,QAAQ,GAAGT,eAAeqB,YAAY,CAACzB,QAAQ,CAACc;gBAC1D,OAAO,IAAI,CAACL,UAAUe,GAAG,CAACX,UAAU;oBAClC,MAAMf,SAASH,iBAAiBkB;oBAChCO,OAAO,CAACP,QAAQ,GAAGf,SACf,MAAMA,SACN,MAAMF,iBACJiB,SACAT,eAAeqB,YAAY,CAACzB,QAAQ,CAACc;gBAE7C;YACF,CAAA;eACG7B,OAAOmC,OAAO,CAAChB,eAAejB,QAAQ,EAAE7B,GAAG,CAC5C,OAAO,CAACuC,IAAI,EAAEI,QAAQ,EAAE,CAAC;gBACvB,MAAMD,WAAWI,eAAejB,QAAQ,CAACU,GAAG,EAAEG;gBAC9C,IAAI,CAACC,UAAU;oBACbmB,OAAO,CAACvB,GAAG,GAAGG,WAAWc;gBAC3B,OAAO,IAAI,CAACL,UAAUe,GAAG,CAAC3B,KAAK;oBAC7B,MAAMC,SAASH,iBAAiBE;oBAChCuB,OAAO,CAACvB,GAAG,GAAGC,SACV,MAAMA,SACN,MAAMF,iBAAiBC,IAAIG,WAAWc;gBAC5C;YACF;eAECC,OAAOzD,GAAG,CAAC,OAAO4D;gBACnB,MAAMrB,KAAK3B,uBAAuBgD;gBAClC,MAAMxB,cAAcsB,eAAehF,GAAG,CAACkF;gBACvC,IAAI,CAACxB,aAAa;oBAChB,MAAM,IAAIpB,MAAM,CAAC,iBAAiB,EAAE4C,SAAS;gBAC/C;gBACA,IAAIxB,YAAYO,QAAQ,IAAIQ,UAAUe,GAAG,CAAC3B,KAAK;oBAC7C,OAAO;gBACT;gBACA,MAAM6B,eAAe,MAAMjC,gBACzBC,aACAC,kBACAC;gBAEFwB,OAAO,CAACvB,GAAG,GAAG6B;YAChB;SACD;QACDN,OAAO,CAACpG,SAAS,GAAG;YAAC2F;YAAiB5E;SAAM;QAC5CqF,OAAO,CAACrG,aAAa,GAAGqF,eAAeH,QAAQ;QAC/Ce,eAAejC,OAAO,CAAC,CAACW,aAAawB;YACnC,IAAIxB,YAAYO,QAAQ,EAAE;gBACxB,4BAA4B;gBAC5BmB,OAAO,CAACrG,eAAe,MAAMmD,uBAAuBgD,QAAQ,GAAG;YACjE;QACF;QACA,IAAI5B,SAASR,MAAM,EAAE;YACnBsC,OAAO,CAACtG,UAAU,GAAG;QACvB;QACA,OAAOsG;IACT;IAKA,MAAMO,2BAA2B,IAAIV;IACrC,IAAIW,sCAAsC;IAC1C,MAAMC,gBAA+B,OACnCC,OACA,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,iBAAiB,EAAE;QAEtD,MAAMvC,mBAAmB,CAACE,KAAe8B,yBAAyB3F,GAAG,CAAC6D;QACtE,MAAMD,mBAAmB,CAACC,IAAYE;YACpC,MAAMD,SAAS6B,yBAAyB3F,GAAG,CAAC6D;YAC5C,IAAIC,QAAQ;gBACV,OAAOA;YACT;YACA,MAAMqC,SAASJ,UAAU;gBAAE,CAAClC,GAAG,EAAEE;YAAQ,GAAGqC,IAAI,CAAC,CAACC,YAChDL,SAASK,WAAWD,IAAI,CAAC,CAACE,SAAWA,MAAM,CAACzC,GAAG;YAEjD8B,yBAAyBR,GAAG,CAACtB,IAAIsC;YACjC,OAAOA;QACT;QACA,IAAI,CAACP,qCAAqC;YACxCA,sCAAsC;YACtC,MAAMW,yBAAyB,MAAML,kBACnC;YAEF,IAAIK,wBAAwB;gBAC1BtD,OAAOmC,OAAO,CAACd,KAAKC,KAAK,CAACgC,yBAAyBxD,OAAO,CACxD,CAAC,CAACc,IAAI2C,IAAI;oBACRb,yBAAyBR,GAAG,CAC1BtB,IACAmC,SAAS1H,eAAekI,MAAgBJ,IAAI,CAC1C,CAACE,SAAWA,MAAM,CAACzC,GAAG;gBAG5B;YAEJ;QACF;QACA,MAAMO,iBAAiB,MAAMf,kBAAkByC,MAAMnE,QAAQ;QAC7D,IAAIyC,gBAAgBlD,SAAS,OAAO;YAClC,MAAMuF,MAAM,IAAIC,IAAIZ,MAAMa,GAAG,CAACF,GAAG;YACjCA,IAAI9E,QAAQ,GAAGmE,MAAMnE,QAAQ;YAC7B,MAAMgF,MAAM,IAAIC,QAAQH,KAAKX,MAAMa,GAAG;YACtC,OAAOvC,eAAeyC,OAAO,CAACF;QAChC;QACA,MAAMF,MAAM,IAAIC,IAAIZ,MAAMa,GAAG,CAACF,GAAG;QACjC,MAAMtC,UAAUlB,OAAO6D,WAAW,CAAChB,MAAMa,GAAG,CAACxC,OAAO,CAACiB,OAAO;QAC5D,IAAIU,MAAM5E,IAAI,KAAK,aAAa;YAC9B,MAAMgE,UAAU/F,cAAc2G,MAAMzF,OAAO;YAC3C,IAAI6E,YAAY,MAAM;gBACpB,8CAA8C;gBAC9C,6EAA6E;gBAC7E,MAAMxB,cAAc,MAAMhB,cAAc0D,IAAI,CAAC,CAAC9C,WAC5CA,SAASX,OAAO,CAACa,IAAI,CACnB,CAACR,OACCA,KAAK9B,IAAI,KAAK,WAAW8B,KAAKa,EAAE,KAAKqB;gBAG3C,IAAI,CAACxB,aAAa;oBAChB,OAAO;gBACT;gBACA,MAAMgC,eAAe,MAAMjC,gBACzBC,aACAC,kBACAC;gBAEF,OAAOmC,UAAU;oBACf,CAAC7D,uBAAuBgD,QAAQ,EAAEQ;oBAClC,GAAIhC,YAAYO,QAAQ,GACpB;wBACE,4BAA4B;wBAC5B,CAAClF,eAAe,MAAMmD,uBAAuBgD,QAAQ,EAAE;oBACzD,IACA,CAAC,CAAC;gBACR;YACF;YACA,MAAME,UAAU,MAAMlB,mBACpB4B,MAAMzF,OAAO,EACbyF,MAAMjG,SAAS,EACfsE,SACAR,kBACAC;YAEF,IAAI,CAACwB,SAAS;gBACZ,OAAO;YACT;YACA,OAAOW,UAAUX;QACnB;QACA,IAAIU,MAAM5E,IAAI,KAAK,YAAY;YAC7B,IAAI6F,kBAAoD1B,QAAQ2B,OAAO,CACrE,CAAC;YAEH,IAAIC,WAAW;YACf,MAAMpG,WAAW,CAACR,SAAiBR;gBACjC,IAAIoH,UAAU;oBACZ,MAAM,IAAI3E,MAAM;gBAClB;gBACAyE,kBAAkB1B,QAAQC,GAAG,CAAC;oBAC5ByB;oBACA7C,mBACE7D,SACAR,WACAsE,SACAR,kBACAC;iBAEH,EAAEwC,IAAI,CAAC,CAAC,CAACc,aAAaC,YAAY;oBACjC,IAAIA,gBAAgB,MAAM;wBACxBC,QAAQC,IAAI,CAAC;oBACf;oBACA,OAAO;wBACL,GAAGH,WAAW;wBACd,GAAGC,WAAW;oBAChB;gBACF;YACF;YACAvG,YAAYC;YACZ,IAAI;gBACF,MAAMyG,QAAQ,MAAMxB,MAAMyB,EAAE,IAAIzB,MAAM0B,IAAI;gBAC1C,OAAOzB,UAAU;oBAAE,GAAI,MAAMgB,eAAe;oBAAGU,QAAQH;gBAAM;YAC/D,EAAE,OAAOI,GAAG;gBACV,MAAMC,OAAOvJ,aAAasJ;gBAC1B,IAAIC,MAAM5F,UAAU;oBAClB,MAAM1B,UAAUjB,gBAAgBuI,KAAK5F,QAAQ;oBAC7C,MAAMqD,UAAU,MAAMlB,mBACpB7D,SACAI,WACA0D,SACAR,kBACAC;oBAEF,IAAI,CAACwB,SAAS;wBACZxD;oBACF;oBACA,OAAOmE,UAAUX;gBACnB;gBACA,MAAMsC;YACR,SAAU;gBACRT,WAAW;YACb;QACF;QACA,IAAInB,MAAM5E,IAAI,KAAK,YAAY4E,MAAM5E,IAAI,KAAK,UAAU;YACtD,MAAM0G,WAAW,OACfjG,UACA5B,OACA8H,aAAa,GAAG;gBAEhB,MAAMxH,UAAUjB,gBAAgBuC;gBAChC,MAAM9B,YAAY,IAAIC,gBAAgB;oBAAEC;gBAAM;gBAC9C,MAAMqF,UAAU,MAAMlB,mBACpB7D,SACAR,WACAsE,SACAR,kBACAC;gBAEF,IAAI,CAACwB,SAAS;oBACZ,OAAO;gBACT;gBACA,MAAM0C,qBACJ,KAACjJ;oBACCkJ,OAAO;wBAAE3E,MAAMzB;wBAAU5B;wBAAOiI,MAAM;oBAAG;oBACzCH,YAAYA;;gBAGhB,MAAMI,eACJnC,MAAM5E,IAAI,KAAK,WAAW,MAAM4E,MAAMyB,EAAE,KAAK9G;gBAC/C,OAAOwF,WAAW,MAAMF,UAAUX,UAAU0C,MAAM;oBAChDzH;oBACA4H;oBACApG,QAAQgG;gBACV;YACF;YACA,MAAM9H,QAAQ0G,IAAIyB,YAAY,CAACC,QAAQ;YACvC,IAAI/D,gBAAgBlD,SAAS,WAAWkD,eAAegE,KAAK,EAAE;gBAC5D,OAAO;YACT;YACA,IAAI;gBACF,IAAIhE,gBAAgB;oBAClB,OAAO,MAAMwD,SAAS9B,MAAMnE,QAAQ,EAAE5B;gBACxC;YACF,EAAE,OAAO2H,GAAG;gBACV,MAAMC,OAAOvJ,aAAasJ;gBAC1B,IAAIC,MAAM9F,WAAW,KAAK;oBACxB,MAAM6F;gBACR;YACF;YACA,IAAI,AAAC,CAAA,MAAMhF,aAAY,EAAGI,MAAM,EAAE;gBAChC,OAAO8E,SAAS,QAAQ,IAAI;YAC9B,OAAO;gBACL,OAAO;YACT;QACF;IACF;IAEA,MAAMS,cAA2B,OAAO,EACtCtC,SAAS,EACTC,QAAQ,EACRC,UAAU,EACVqC,gBAAgB,EAChBC,iBAAiB,EACjBC,WAAW,EACXC,YAAY,EACZC,mBAAmB,EACpB;QACC,MAAMpF,WAAW,MAAMZ;QACvB,MAAMiG,yBAAyB,IAAI1D;QACnC,MAAM2D,2BAA2B,IAAI3D;QACrC,MAAMtB,mBAAmB,CAACE,KAAe8E,uBAAuB3I,GAAG,CAAC6D;QACpE,MAAMD,mBAAmB,OAAOC,IAAYE;YAC1C,MAAMD,SAAS6E,uBAAuB3I,GAAG,CAAC6D;YAC1C,IAAIC,QAAQ;gBACV,OAAOA;YACT;YACA,MAAM+E,aAAa9C,UAAU;gBAAE,CAAClC,GAAG,EAAEE;YAAQ,GAAGqC,IAAI,CAAC,CAACC,YACpDA,UAAUyC,GAAG;YAEf,MAAMC,UAAUF,WAAWzC,IAAI,CAAC,CAAC,CAAC4C,GAAG,GAAKA;YAC1C,MAAMC,UAAUJ,WAAWzC,IAAI,CAAC,CAAC,GAAG8C,GAAG,GAAKA;YAC5C,MAAM/C,SAAS4C,QAAQ3C,IAAI,CACzB,CAACC,YACCL,SAASK,WAAWD,IAAI,CACtB,CAACE,SAAWA,MAAM,CAACzC,GAAG;YAG5B8E,uBAAuBxD,GAAG,CAACtB,IAAIsC;YAC/ByC,yBAAyBzD,GAAG,CAACtB,IAAI,MAAMtF,eAAe,MAAM0K;YAC5D,OAAO9C;QACT;QAEA,+BAA+B;QAC/B,MAAM,EAAEgD,OAAO,EAAEC,YAAY,EAAE,GAAG5K,iBAAiB;QAEnD,aAAa;QACb,KAAK,MAAMwE,QAAQM,SAASX,OAAO,CAAE;YACnC,IAAIK,KAAK9B,IAAI,KAAK,OAAO;gBACvB;YACF;YACA,IAAI,CAAC8B,KAAKiB,QAAQ,EAAE;gBAClB;YACF;YACA,MAAMtC,WAAWP,kBAAkB4B,KAAKI,IAAI;YAC5C,IAAI,CAACzB,UAAU;gBACb;YACF;YACA,MAAMgF,MAAM,IAAIC,QAAQ,IAAIF,IAAI/E,UAAU;YAC1CwH,QAAQ;gBACN,MAAMX,YAAY7B,KAAK;oBACrB,MAAM0C,MAAM,MAAMrG,KAAK6D,OAAO,CAACF;oBAC/B,MAAM8B,aAAa9G,UAAU0H,IAAIC,IAAI,IAAI;gBAC3C;YACF;QACF;QAEA,eAAe;QACf,KAAK,MAAMtG,QAAQM,SAASX,OAAO,CAAE;YACnC,IAAIK,KAAK9B,IAAI,KAAK,SAAS;gBACzB;YACF;YACA,IAAI,CAAC8B,KAAKiB,QAAQ,EAAE;gBAClB;YACF;YACA,MAAMtC,WAAWP,kBAAkB4B,KAAKI,IAAI;YAC5C,IAAI,CAACzB,UAAU;gBACb;YACF;YACA,MAAMtB,UAAUjB,gBAAgBuC;YAChC,MAAMgF,MAAM,IAAIC,QAAQ,IAAIF,IAAI/E,UAAU;YAC1CwH,QAAQ;gBACN,MAAMX,YAAY7B,KAAK;oBACrB,MAAMvB,UAAU,MAAMlB,mBACpB7D,SACAI,WACA,CAAC,GACDkD,kBACAC;oBAEF,IAAI,CAACwB,SAAS;wBACZ;oBACF;oBACA,KAAK,MAAMvB,MAAMZ,OAAOC,IAAI,CAACkC,SAAU;wBACrC,MAAMtB,SAASH,iBAAiBE;wBAChCuB,OAAO,CAACvB,GAAG,GAAGC,SAAS,MAAMA,SAASsB,OAAO,CAACvB,GAAG;oBACnD;oBACA,MAAM0F,SAAS,MAAMxD,UAAUX;oBAC/B,MAAM,CAAC2D,SAASE,QAAQ,GAAGM,OAAOT,GAAG;oBACrC,MAAML,aAAaH,iBAAiBjI,UAAU0I;oBAC9C,MAAMjB,qBACJ,KAACjJ;wBACCkJ,OAAO;4BAAE3E,MAAMzB;4BAAU5B,OAAO;4BAAIiI,MAAM;wBAAG;wBAC7CH,YAAY9G,MAAMiC,KAAKI,IAAI,IAAI,MAAM;;oBAGzC,MAAMiG,MAAM,MAAMpD,WAAWgD,SAASnB,MAAM;wBAAEzH;oBAAQ;oBACtD,MAAMoI,aAAajH,kBAAkBG,WAAW0H,IAAIC,IAAI,IAAI;gBAC9D;YACF;QACF;QAEA,eAAe;QACf,KAAK,MAAMtG,QAAQM,SAASX,OAAO,CAAE;YACnC,IAAIK,KAAK9B,IAAI,KAAK,SAAS;gBACzB;YACF;YACA,IAAI8B,KAAKoF,KAAK,EAAE;gBACd,MAAMzG,WAAWP,kBAAkB4B,KAAKI,IAAI;gBAC5C,IAAI,CAACzB,UAAU;oBACb,MAAM,IAAIW,MAAM;gBAClB;gBACA6G,QAAQ;oBACN,MAAMT,oBAAoBlH,kBAAkBG;gBAC9C;YACF;QACF;QAEA,eAAe;QACf,KAAK,MAAMqB,QAAQM,SAASX,OAAO,CAAE;YACnC,IAAIK,KAAK9B,IAAI,KAAK,SAAS;gBACzB;YACF;YACA,IAAI,CAAC8B,KAAKiB,QAAQ,EAAE;gBAClB;YACF;YACA,MAAM5D,UAAUhB,cAAc2D,KAAKa,EAAE;YACrC,4DAA4D;YAC5D,MAAM8C,MAAM,IAAIC,QAAQ,IAAIF,IAAI;YAChCyC,QAAQ;gBACN,MAAMX,YAAY7B,KAAK;oBACrB,MAAMjB,eAAe,MAAMjC,gBACzBT,MACAW,kBACAC;oBAEF,MAAM0F,OAAO,MAAMvD,UAAU;wBAC3B,CAAC7D,uBAAuBc,KAAKa,EAAE,CAAC,EAAE6B;wBAClC,4BAA4B;wBAC5B,CAAC3G,eAAe,MAAMmD,uBAAuBc,KAAKa,EAAE,CAAC,EAAE;oBACzD;oBACA,MAAM4E,aAAaH,iBAAiBjI,UAAUiJ;gBAChD;YACF;QACF;QAEA,MAAMF;QAEN,6DAA6D;QAC7D,MAAMb,kBACJ,+BACAjE,KAAKkF,SAAS,CAACvG,OAAO6D,WAAW,CAAC8B;IAEtC;IAEA,OAAO3F,OAAOwG,MAAM,CAAC/K,eAAe;QAAEmH;QAAewC;IAAY,IAAI;QACnEqB,2BAA2B,IAAMhH,cAAc0D,IAAI,CAAC,CAACuD,IAAMA,EAAEhH,OAAO;IACtE;AACF"}