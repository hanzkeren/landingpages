import { Component } from 'react';
import type { AnchorHTMLAttributes, ReactElement, ReactNode, Ref, TransitionFunction } from 'react';
import type { RouteConfig } from './base-types.js';
import type { RouteProps } from './common.js';
type AllowPathDecorators<Path extends string> = Path extends unknown ? Path | `${Path}?${string}` | `${Path}#${string}` : never;
type InferredPaths = RouteConfig extends {
    paths: infer UserPaths extends string;
} ? AllowPathDecorators<UserPaths> : string;
type ChangeRouteEvent = 'start' | 'complete';
type ChangeRouteCallback = (route: RouteProps) => void;
type SliceId = string;
export declare function useRouter(): {
    push: (to: InferredPaths, options?: {
        /**
         * indicates if the link should scroll or not on navigation
         * - `true`: always scroll
         * - `false`: never scroll
         * - `undefined`: scroll on path change (not on searchParams change)
         */
        scroll?: boolean;
    }) => Promise<void>;
    replace: (to: InferredPaths, options?: {
        /**
         * indicates if the link should scroll or not on navigation
         * - `true`: always scroll
         * - `false`: never scroll
         * - `undefined`: scroll on path change (not on searchParams change)
         */
        scroll?: boolean;
    }) => Promise<void>;
    reload: () => Promise<void>;
    back: () => void;
    forward: () => void;
    prefetch: (to: string) => void;
    unstable_events: Record<"on" | "off", (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void>;
    path: string;
    query: string;
    hash: string;
};
export type LinkProps = {
    to: InferredPaths;
    children: ReactNode;
    /**
     * indicates if the link should scroll or not on navigation
     * - `true`: always scroll
     * - `false`: never scroll
     * - `undefined`: scroll on path change (not on searchParams change)
     */
    scroll?: boolean;
    unstable_pending?: ReactNode;
    unstable_notPending?: ReactNode;
    unstable_prefetchOnEnter?: boolean;
    unstable_prefetchOnView?: boolean;
    unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;
    ref?: Ref<HTMLAnchorElement> | undefined;
} & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;
export declare function Link({ to, children, scroll, unstable_pending, unstable_notPending, unstable_prefetchOnEnter, unstable_prefetchOnView, unstable_startTransition, ref: refProp, ...props }: LinkProps): ReactElement;
export declare class ErrorBoundary extends Component<{
    children: ReactNode;
}, {
    error?: unknown;
}> {
    constructor(props: {
        children: ReactNode;
    });
    static getDerivedStateFromError(error: unknown): {
        error: unknown;
    };
    render(): string | number | bigint | boolean | Iterable<ReactNode> | Promise<string | number | bigint | boolean | import("react").ReactPortal | ReactElement<unknown, string | import("react").JSXElementConstructor<any>> | Iterable<ReactNode> | null | undefined> | import("react/jsx-runtime").JSX.Element | null | undefined;
}
export declare function Slice({ id, children, ...props }: {
    id: SliceId;
    children?: ReactNode;
} & ({
    lazy?: false;
} | {
    lazy: true;
    fallback: ReactNode;
})): string | number | bigint | boolean | Iterable<ReactNode> | Promise<string | number | bigint | boolean | import("react").ReactPortal | ReactElement<unknown, string | import("react").JSXElementConstructor<any>> | Iterable<ReactNode> | null | undefined> | import("react/jsx-runtime").JSX.Element | null | undefined;
export declare function Router({ initialRoute, }: {
    initialRoute?: RouteProps;
}): import("react/jsx-runtime").JSX.Element;
/**
 * ServerRouter for SSR
 * This is not a public API.
 */
export declare function INTERNAL_ServerRouter({ route, httpstatus, }: {
    route: RouteProps;
    httpstatus: number;
}): import("react/jsx-runtime").JSX.Element;
export {};
