{"version":3,"sources":["../../src/router/common.ts"],"sourcesContent":["export type RouteProps<Path extends string = string> = {\n  path: Path;\n  query: string;\n  hash: string;\n};\n\nexport function getComponentIds(path: string): readonly string[] {\n  const pathItems = path.split('/').filter(Boolean);\n  const idSet = new Set<string>();\n  for (let index = 0; index <= pathItems.length; ++index) {\n    const id = [...pathItems.slice(0, index), 'layout'].join('/');\n    idSet.add(id);\n  }\n  idSet.add([...pathItems, 'page'].join('/'));\n  return ['root', ...Array.from(idSet)];\n}\n\nconst ROUTE_PREFIX = 'R';\nconst SLICE_PREFIX = 'S/';\n\nexport function encodeRoutePath(path: string): string {\n  if (!path.startsWith('/')) {\n    throw new Error('Path must start with `/`: ' + path);\n  }\n  if (path.length > 1 && path.endsWith('/')) {\n    throw new Error('Path must not end with `/`: ' + path);\n  }\n  if (path === '/') {\n    return ROUTE_PREFIX + '/_root';\n  }\n  if (path.startsWith('/_')) {\n    return ROUTE_PREFIX + '/__' + path.slice(2);\n  }\n  return ROUTE_PREFIX + path;\n}\n\nexport function decodeRoutePath(rscPath: string): string {\n  if (!rscPath.startsWith(ROUTE_PREFIX)) {\n    throw new Error('rscPath should start with: ' + ROUTE_PREFIX);\n  }\n  if (rscPath === ROUTE_PREFIX + '/_root') {\n    return '/';\n  }\n  if (rscPath.startsWith(ROUTE_PREFIX + '/__')) {\n    return '/_' + rscPath.slice(ROUTE_PREFIX.length + 3);\n  }\n  return rscPath.slice(ROUTE_PREFIX.length);\n}\n\n// LIMITATION: This is very limited because it does not support fetching multiple slices in one request. We should generally prefer sending slices with the route if possible.\nexport function encodeSliceId(sliceId: string): string {\n  if (sliceId.startsWith('/')) {\n    throw new Error('Slice id must not start with `/`: ' + sliceId);\n  }\n  return SLICE_PREFIX + sliceId;\n}\n\nexport function decodeSliceId(rscPath: string): string | null {\n  if (!rscPath.startsWith(SLICE_PREFIX)) {\n    return null;\n  }\n  return rscPath.slice(SLICE_PREFIX.length);\n}\n\nexport const ROUTE_ID = 'ROUTE';\nexport const IS_STATIC_ID = 'IS_STATIC';\nexport const HAS404_ID = 'HAS404';\n\n// For HTTP header\nexport const SKIP_HEADER = 'X-Waku-Router-Skip';\n"],"names":["getComponentIds","path","pathItems","split","filter","Boolean","idSet","Set","index","length","id","slice","join","add","Array","from","ROUTE_PREFIX","SLICE_PREFIX","encodeRoutePath","startsWith","Error","endsWith","decodeRoutePath","rscPath","encodeSliceId","sliceId","decodeSliceId","ROUTE_ID","IS_STATIC_ID","HAS404_ID","SKIP_HEADER"],"mappings":"AAMA,OAAO,SAASA,gBAAgBC,IAAY;IAC1C,MAAMC,YAAYD,KAAKE,KAAK,CAAC,KAAKC,MAAM,CAACC;IACzC,MAAMC,QAAQ,IAAIC;IAClB,IAAK,IAAIC,QAAQ,GAAGA,SAASN,UAAUO,MAAM,EAAE,EAAED,MAAO;QACtD,MAAME,KAAK;eAAIR,UAAUS,KAAK,CAAC,GAAGH;YAAQ;SAAS,CAACI,IAAI,CAAC;QACzDN,MAAMO,GAAG,CAACH;IACZ;IACAJ,MAAMO,GAAG,CAAC;WAAIX;QAAW;KAAO,CAACU,IAAI,CAAC;IACtC,OAAO;QAAC;WAAWE,MAAMC,IAAI,CAACT;KAAO;AACvC;AAEA,MAAMU,eAAe;AACrB,MAAMC,eAAe;AAErB,OAAO,SAASC,gBAAgBjB,IAAY;IAC1C,IAAI,CAACA,KAAKkB,UAAU,CAAC,MAAM;QACzB,MAAM,IAAIC,MAAM,+BAA+BnB;IACjD;IACA,IAAIA,KAAKQ,MAAM,GAAG,KAAKR,KAAKoB,QAAQ,CAAC,MAAM;QACzC,MAAM,IAAID,MAAM,iCAAiCnB;IACnD;IACA,IAAIA,SAAS,KAAK;QAChB,OAAOe,eAAe;IACxB;IACA,IAAIf,KAAKkB,UAAU,CAAC,OAAO;QACzB,OAAOH,eAAe,QAAQf,KAAKU,KAAK,CAAC;IAC3C;IACA,OAAOK,eAAef;AACxB;AAEA,OAAO,SAASqB,gBAAgBC,OAAe;IAC7C,IAAI,CAACA,QAAQJ,UAAU,CAACH,eAAe;QACrC,MAAM,IAAII,MAAM,gCAAgCJ;IAClD;IACA,IAAIO,YAAYP,eAAe,UAAU;QACvC,OAAO;IACT;IACA,IAAIO,QAAQJ,UAAU,CAACH,eAAe,QAAQ;QAC5C,OAAO,OAAOO,QAAQZ,KAAK,CAACK,aAAaP,MAAM,GAAG;IACpD;IACA,OAAOc,QAAQZ,KAAK,CAACK,aAAaP,MAAM;AAC1C;AAEA,8KAA8K;AAC9K,OAAO,SAASe,cAAcC,OAAe;IAC3C,IAAIA,QAAQN,UAAU,CAAC,MAAM;QAC3B,MAAM,IAAIC,MAAM,uCAAuCK;IACzD;IACA,OAAOR,eAAeQ;AACxB;AAEA,OAAO,SAASC,cAAcH,OAAe;IAC3C,IAAI,CAACA,QAAQJ,UAAU,CAACF,eAAe;QACrC,OAAO;IACT;IACA,OAAOM,QAAQZ,KAAK,CAACM,aAAaR,MAAM;AAC1C;AAEA,OAAO,MAAMkB,WAAW,QAAQ;AAChC,OAAO,MAAMC,eAAe,YAAY;AACxC,OAAO,MAAMC,YAAY,SAAS;AAElC,kBAAkB;AAClB,OAAO,MAAMC,cAAc,qBAAqB"}