import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { createElement } from 'react';
import { getGrouplessPath } from '../lib/utils/create-pages.js';
import { getPathMapping, joinPath, parseExactPath, parsePathWithSlug, pathSpecAsString } from '../lib/utils/path.js';
import { Children, Slot } from '../minimal/client.js';
import { ErrorBoundary } from '../router/client.js';
import { unstable_defineRouter } from './define-router.js';
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods
export const METHODS = [
    'GET',
    'HEAD',
    'POST',
    'PUT',
    'DELETE',
    'CONNECT',
    'OPTIONS',
    'TRACE',
    'PATCH'
];
export const pathMappingWithoutGroups = (pathSpec, pathname)=>{
    const cleanPathSpec = pathSpec.filter((spec)=>!(spec.type === 'literal' && spec.name.startsWith('(')));
    return getPathMapping(cleanPathSpec, pathname);
};
const sanitizeSlug = (slug)=>slug.replace(/ /g, '-');
/**
 * Root component for all pages
 * ```tsx
 *   <html>
 *     <head></head>
 *     <body>{children}</body>
 *   </html>
 * ```
 */ const DefaultRoot = ({ children })=>/*#__PURE__*/ _jsx(ErrorBoundary, {
        children: /*#__PURE__*/ _jsxs("html", {
            children: [
                /*#__PURE__*/ _jsx("head", {}),
                /*#__PURE__*/ _jsx("body", {
                    children: children
                })
            ]
        })
    });
const createNestedElements = (elements, children)=>elements.reduceRight((result, element)=>/*#__PURE__*/ createElement(element.component, element.props, result), children);
const routePriorityComparator = (a, b)=>{
    const aPath = a.path;
    const bPath = b.path;
    const aPathLength = aPath.length;
    const bPathLength = bPath.length;
    const aHasWildcard = aPath.at(-1)?.type === 'wildcard';
    const bHasWildcard = bPath.at(-1)?.type === 'wildcard';
    // Special case: root route (length 0) should come before wildcard routes
    // This ensures exact matches like "/" are checked before catch-all routes like "/[...notFound]"
    if (aPathLength === 0 && bHasWildcard) {
        return -1;
    }
    if (bPathLength === 0 && aHasWildcard) {
        return 1;
    }
    // Compare path lengths first (longer paths are more specific)
    if (aPathLength !== bPathLength) {
        return aPathLength > bPathLength ? -1 : 1;
    }
    // If path lengths are equal, compare wildcard presence
    // sort the route without the wildcard higher, to check it earlier
    if (aHasWildcard !== bHasWildcard) {
        return aHasWildcard ? 1 : -1;
    }
    // If all else is equal, routes have the same priority
    return 0;
};
export const createPages = (fn)=>{
    let configured = false;
    // layout lookups retain (group) path and pathMaps store without group
    // paths are stored without groups to easily detect duplicates
    const groupPathLookup = new Map();
    const staticPathMap = new Map();
    const dynamicPagePathMap = new Map();
    const wildcardPagePathMap = new Map();
    const dynamicLayoutPathMap = new Map();
    const apiPathMap = new Map();
    const staticComponentMap = new Map();
    const getStaticLayout = (id)=>staticComponentMap.get(joinPath(id, 'layout').slice(1));
    const getDynamicLayout = (segment)=>dynamicLayoutPathMap.get(segment)?.[1];
    const slicePathMap = new Map();
    const sliceIdMap = new Map();
    let rootItem = undefined;
    const noSsrSet = new WeakSet();
    const pagePathExists = (path)=>{
        for (const pathKey of apiPathMap.keys()){
            const [_m, p] = pathKey.split(' ');
            if (p === path) {
                return true;
            }
        }
        return staticPathMap.has(path) || dynamicPagePathMap.has(path) || wildcardPagePathMap.has(path);
    };
    /** Creates a function to map pathname to component props */ const createPathPropsMapper = (path)=>{
        const layoutMatchPath = groupPathLookup.get(path) ?? path;
        const pathSpec = parsePathWithSlug(layoutMatchPath);
        return (pathname)=>pathMappingWithoutGroups(pathSpec, encodeURI(pathname));
    };
    /** Builds the routeElement renderer from layouts and page slots */ const buildRouteElement = (layoutPaths, path, pageComponent)=>{
        const layouts = layoutPaths.map((lPath)=>({
                component: Slot,
                props: {
                    id: `layout:${lPath}`
                }
            }));
        const finalPageChildren = Array.isArray(pageComponent) ? /*#__PURE__*/ _jsx(_Fragment, {
            children: pageComponent.map((_comp, order)=>/*#__PURE__*/ _jsx(Slot, {
                    id: `page:${path}:${order}`
                }, `page:${path}:${order}`))
        }) : /*#__PURE__*/ _jsx(Slot, {
            id: `page:${path}`
        });
        return ()=>createNestedElements(layouts, finalPageChildren);
    };
    /** Renders the root component */ const renderRoot = ()=>/*#__PURE__*/ createElement(rootItem ? rootItem.component : DefaultRoot, null, /*#__PURE__*/ _jsx(Children, {}));
    const registerStaticComponent = (id, component)=>{
        if (staticComponentMap.has(id) && staticComponentMap.get(id) !== component) {
            throw new Error(`Duplicated component for: ${id}`);
        }
        staticComponentMap.set(id, component);
    };
    const isAllElementsStatic = (elements)=>Object.values(elements).every((element)=>element.isStatic);
    const isAllSlicesStatic = (path)=>(slicePathMap.get(path) || []).every((sliceId)=>sliceIdMap.get(sliceId)?.isStatic);
    const createPage = (page)=>{
        if (configured) {
            throw new Error('createPage no longer available');
        }
        if (pagePathExists(page.path)) {
            throw new Error(`Duplicated path: ${page.path}`);
        }
        const pathSpec = parsePathWithSlug(page.path);
        const { numSlugs, numWildcards } = getSlugsAndWildcards(pathSpec);
        if (page.unstable_disableSSR) {
            noSsrSet.add(pathSpec);
        }
        if (page.exactPath) {
            const spec = parseExactPath(page.path);
            if (page.render === 'static') {
                staticPathMap.set(page.path, {
                    literalSpec: spec
                });
                const id = joinPath(page.path, 'page').replace(/^\//, '');
                if (page.component) {
                    registerStaticComponent(id, page.component);
                }
            } else if (page.component) {
                dynamicPagePathMap.set(page.path, [
                    spec,
                    page.component
                ]);
            } else {
                dynamicPagePathMap.set(page.path, [
                    spec,
                    []
                ]);
            }
        } else if (page.render === 'static' && numSlugs === 0) {
            const pagePath = getGrouplessPath(page.path);
            staticPathMap.set(pagePath, {
                literalSpec: pathSpec
            });
            const id = joinPath(pagePath, 'page').replace(/^\//, '');
            if (pagePath !== page.path) {
                groupPathLookup.set(pagePath, page.path);
            }
            if (page.component) {
                registerStaticComponent(id, page.component);
            }
        } else if (page.render === 'static' && numSlugs > 0 && 'staticPaths' in page) {
            const staticPaths = page.staticPaths.map((item)=>(Array.isArray(item) ? item : [
                    item
                ]).map(sanitizeSlug));
            for (const staticPath of staticPaths){
                if (staticPath.length !== numSlugs && numWildcards === 0) {
                    throw new Error('staticPaths does not match with slug pattern');
                }
                const { definedPath, pathItems, mapping } = expandStaticPathSpec(pathSpec, staticPath);
                const pagePath = getGrouplessPath(definedPath);
                staticPathMap.set(pagePath, {
                    literalSpec: pathItems.map((name)=>({
                            type: 'literal',
                            name
                        })),
                    originalSpec: pathSpec
                });
                if (pagePath !== definedPath) {
                    groupPathLookup.set(pagePath, definedPath);
                }
                const id = joinPath(pagePath, 'page').replace(/^\//, '');
                const WrappedComponent = (props)=>/*#__PURE__*/ createElement(page.component, {
                        ...props,
                        ...mapping
                    });
                registerStaticComponent(id, WrappedComponent);
            }
        } else if (page.render === 'dynamic' && numWildcards === 0) {
            const pagePath = getGrouplessPath(page.path);
            if (pagePath !== page.path) {
                groupPathLookup.set(pagePath, page.path);
            }
            dynamicPagePathMap.set(pagePath, [
                pathSpec,
                page.component
            ]);
        } else if (page.render === 'dynamic' && numWildcards === 1) {
            const pagePath = getGrouplessPath(page.path);
            if (pagePath !== page.path) {
                groupPathLookup.set(pagePath, page.path);
            }
            wildcardPagePathMap.set(pagePath, [
                pathSpec,
                page.component
            ]);
        } else {
            throw new Error('Invalid page configuration ' + JSON.stringify(page));
        }
        if (page.slices?.length) {
            slicePathMap.set(page.path, page.slices);
        }
        return page;
    };
    const createLayout = (layout)=>{
        if (configured) {
            throw new Error('createLayout no longer available');
        }
        if (layout.render === 'static') {
            const id = joinPath(layout.path, 'layout').replace(/^\//, '');
            registerStaticComponent(id, layout.component);
        } else if (layout.render === 'dynamic') {
            if (dynamicLayoutPathMap.has(layout.path)) {
                throw new Error(`Duplicated dynamic path: ${layout.path}`);
            }
            const pathSpec = parsePathWithSlug(layout.path);
            dynamicLayoutPathMap.set(layout.path, [
                pathSpec,
                layout.component
            ]);
        } else {
            throw new Error('Invalid layout configuration');
        }
    };
    const createApi = (options)=>{
        if (configured) {
            throw new Error('createApi no longer available');
        }
        if (apiPathMap.has(options.path)) {
            throw new Error(`Duplicated api path: ${options.path}`);
        }
        const pathSpec = parsePathWithSlug(options.path);
        if (options.render === 'static') {
            const { numSlugs, numWildcards } = getSlugsAndWildcards(pathSpec);
            if (numSlugs > 0 && options.staticPaths) {
                const staticPaths = options.staticPaths.map((item)=>(Array.isArray(item) ? item : [
                        item
                    ]).map(sanitizeSlug));
                for (const staticPath of staticPaths){
                    if (staticPath.length !== numSlugs && numWildcards === 0) {
                        throw new Error('staticPaths does not match with slug pattern');
                    }
                    const { definedPath, pathItems } = expandStaticPathSpec(pathSpec, staticPath);
                    if (apiPathMap.has(definedPath)) {
                        throw new Error(`Duplicated api path: ${definedPath}`);
                    }
                    apiPathMap.set(definedPath, {
                        render: 'static',
                        pathSpec: pathItems.map((name)=>({
                                type: 'literal',
                                name
                            })),
                        handlers: {
                            GET: options.handler
                        }
                    });
                }
            } else {
                apiPathMap.set(options.path, {
                    render: 'static',
                    pathSpec,
                    handlers: {
                        GET: options.handler
                    }
                });
            }
        } else {
            apiPathMap.set(options.path, {
                render: 'dynamic',
                pathSpec,
                handlers: options.handlers
            });
        }
    };
    const createRoot = (root)=>{
        if (configured) {
            throw new Error('createRoot no longer available');
        }
        if (rootItem) {
            throw new Error(`Duplicated root component`);
        }
        if (root.render === 'static' || root.render === 'dynamic') {
            rootItem = root;
        } else {
            throw new Error('Invalid root configuration');
        }
    };
    const createSlice = (slice)=>{
        if (configured) {
            throw new Error('createSlice no longer available');
        }
        if (sliceIdMap.has(slice.id)) {
            throw new Error(`Duplicated slice id: ${slice.id}`);
        }
        sliceIdMap.set(slice.id, {
            component: slice.component,
            isStatic: slice.render === 'static'
        });
    };
    let ready;
    const configure = async ()=>{
        if (!configured && !ready) {
            ready = fn({
                createPage,
                createLayout,
                createRoot,
                createApi,
                createSlice
            });
            await ready;
            configured = true;
        }
        await ready;
    };
    const getLayouts = (spec)=>{
        const pathSegments = spec.reduce((acc, _segment, index)=>{
            acc.push(pathSpecAsString(spec.slice(0, index + 1)));
            return acc;
        }, [
            '/'
        ]);
        return pathSegments.filter((segment)=>dynamicLayoutPathMap.has(segment) || getStaticLayout(segment));
    };
    const definedRouter = unstable_defineRouter({
        getConfigs: async ()=>{
            await configure();
            const routeConfigs = [];
            const rootIsStatic = !rootItem || rootItem.render === 'static';
            for (const [path, { literalSpec, originalSpec }] of staticPathMap){
                const noSsr = noSsrSet.has(literalSpec);
                const layoutPaths = getLayouts(originalSpec ?? literalSpec);
                const pageComponent = staticComponentMap.get(joinPath(path, 'page').slice(1));
                const getPropsMapping = createPathPropsMapper(path);
                const elements = {};
                // Add layout elements
                for (const lPath of layoutPaths){
                    const layout = getDynamicLayout(lPath) ?? getStaticLayout(lPath);
                    if (!layout || Array.isArray(layout)) {
                        throw new Error('Invalid layout ' + lPath);
                    }
                    elements[`layout:${lPath}`] = {
                        isStatic: !dynamicLayoutPathMap.has(lPath),
                        renderer: ()=>/*#__PURE__*/ createElement(layout, null, /*#__PURE__*/ _jsx(Children, {}))
                    };
                }
                // Add page element
                elements[`page:${path}`] = {
                    isStatic: true,
                    renderer: (option)=>/*#__PURE__*/ createElement(pageComponent, {
                            ...getPropsMapping(option.pathname),
                            ...option.query ? {
                                query: option.query
                            } : {},
                            path: option.pathname
                        }, /*#__PURE__*/ _jsx(Children, {}))
                };
                routeConfigs.push({
                    type: 'route',
                    path: literalSpec.filter((part)=>!part.name?.startsWith('(')),
                    isStatic: rootIsStatic && isAllElementsStatic(elements) && isAllSlicesStatic(path),
                    ...originalSpec && {
                        pathPattern: originalSpec
                    },
                    rootElement: {
                        isStatic: rootIsStatic,
                        renderer: renderRoot
                    },
                    routeElement: {
                        isStatic: true,
                        renderer: buildRouteElement(layoutPaths, path, pageComponent)
                    },
                    elements,
                    noSsr,
                    slices: slicePathMap.get(path) || []
                });
            }
            for (const [path, [pathSpec, components]] of dynamicPagePathMap){
                const noSsr = noSsrSet.has(pathSpec);
                const layoutPaths = getLayouts(pathSpec);
                const getPropsMapping = createPathPropsMapper(path);
                const elements = {};
                // Add layout elements
                for (const lPath of layoutPaths){
                    const layout = getDynamicLayout(lPath) ?? getStaticLayout(lPath);
                    if (!layout || Array.isArray(layout)) {
                        throw new Error('Invalid layout ' + lPath);
                    }
                    elements[`layout:${lPath}`] = {
                        isStatic: !dynamicLayoutPathMap.has(lPath),
                        renderer: ()=>/*#__PURE__*/ createElement(layout, null, /*#__PURE__*/ _jsx(Children, {}))
                    };
                }
                // Add page elements
                if (Array.isArray(components)) {
                    for(let i = 0; i < components.length; i++){
                        const comp = components[i];
                        if (comp) {
                            elements[`page:${path}:${i}`] = {
                                isStatic: comp.render === 'static',
                                renderer: (option)=>/*#__PURE__*/ createElement(comp.component, {
                                        ...getPropsMapping(option.pathname),
                                        ...option.query ? {
                                            query: option.query
                                        } : {},
                                        path: option.pathname
                                    })
                            };
                        }
                    }
                } else {
                    elements[`page:${path}`] = {
                        isStatic: false,
                        renderer: (option)=>/*#__PURE__*/ createElement(components, {
                                ...getPropsMapping(option.pathname),
                                ...option.query ? {
                                    query: option.query
                                } : {},
                                path: option.pathname
                            }, /*#__PURE__*/ _jsx(Children, {}))
                    };
                }
                routeConfigs.push({
                    type: 'route',
                    isStatic: rootIsStatic && isAllElementsStatic(elements) && isAllSlicesStatic(path),
                    path: pathSpec.filter((part)=>!part.name?.startsWith('(')),
                    rootElement: {
                        isStatic: rootIsStatic,
                        renderer: renderRoot
                    },
                    routeElement: {
                        isStatic: true,
                        renderer: buildRouteElement(layoutPaths, path, components)
                    },
                    elements,
                    noSsr,
                    slices: slicePathMap.get(path) || []
                });
            }
            for (const [path, [pathSpec, components]] of wildcardPagePathMap){
                const noSsr = noSsrSet.has(pathSpec);
                const layoutPaths = getLayouts(pathSpec);
                const getPropsMapping = createPathPropsMapper(path);
                const elements = {};
                // Add layout elements
                for (const lPath of layoutPaths){
                    const layout = getDynamicLayout(lPath) ?? getStaticLayout(lPath);
                    if (!layout || Array.isArray(layout)) {
                        throw new Error('Invalid layout ' + lPath);
                    }
                    elements[`layout:${lPath}`] = {
                        isStatic: !dynamicLayoutPathMap.has(lPath),
                        renderer: ()=>/*#__PURE__*/ createElement(layout, null, /*#__PURE__*/ _jsx(Children, {}))
                    };
                }
                // Add page elements
                if (Array.isArray(components)) {
                    for(let i = 0; i < components.length; i++){
                        const comp = components[i];
                        if (comp) {
                            elements[`page:${path}:${i}`] = {
                                isStatic: comp.render === 'static',
                                renderer: (option)=>/*#__PURE__*/ createElement(comp.component, {
                                        ...getPropsMapping(option.pathname),
                                        ...option.query ? {
                                            query: option.query
                                        } : {},
                                        path: option.pathname
                                    })
                            };
                        }
                    }
                } else {
                    elements[`page:${path}`] = {
                        isStatic: false,
                        renderer: (option)=>/*#__PURE__*/ createElement(components, {
                                ...getPropsMapping(option.pathname),
                                ...option.query ? {
                                    query: option.query
                                } : {},
                                path: option.pathname
                            }, /*#__PURE__*/ _jsx(Children, {}))
                    };
                }
                routeConfigs.push({
                    type: 'route',
                    isStatic: rootIsStatic && isAllElementsStatic(elements) && isAllSlicesStatic(path),
                    path: pathSpec.filter((part)=>!part.name?.startsWith('(')),
                    rootElement: {
                        isStatic: rootIsStatic,
                        renderer: renderRoot
                    },
                    routeElement: {
                        isStatic: true,
                        renderer: buildRouteElement(layoutPaths, path, components)
                    },
                    elements,
                    noSsr,
                    slices: slicePathMap.get(path) || []
                });
            }
            const apiConfigs = Array.from(apiPathMap.values()).map(({ pathSpec, render, handlers })=>{
                return {
                    type: 'api',
                    path: pathSpec,
                    isStatic: render === 'static',
                    handler: async (req)=>{
                        const path = new URL(req.url).pathname;
                        const method = req.method;
                        const handler = handlers[method] ?? handlers.all;
                        if (!handler) {
                            throw new Error('API method not found: ' + method + 'for path: ' + path);
                        }
                        return handler(req);
                    }
                };
            });
            const sliceConfigs = Array.from(sliceIdMap).map(([id, { isStatic }])=>({
                    type: 'slice',
                    id,
                    isStatic,
                    renderer: async ()=>{
                        const slice = sliceIdMap.get(id);
                        if (!slice) {
                            throw new Error('Slice not found: ' + id);
                        }
                        return /*#__PURE__*/ _jsx(slice.component, {});
                    }
                }));
            const pathConfigs = [
                ...routeConfigs,
                ...apiConfigs
            ]// Sort routes by priority: "standard routes" -> api routes -> api wildcard routes -> standard wildcard routes
            .sort((configA, configB)=>routePriorityComparator(configA, configB));
            return [
                ...pathConfigs,
                ...sliceConfigs
            ];
        }
    });
    return definedRouter;
};
const getSlugsAndWildcards = (pathSpec)=>{
    let numSlugs = 0;
    let numWildcards = 0;
    for (const slug of pathSpec){
        if (slug.type !== 'literal') {
            numSlugs++;
        }
        if (slug.type === 'wildcard') {
            numWildcards++;
        }
    }
    return {
        numSlugs,
        numWildcards
    };
};
function expandStaticPathSpec(pathSpec, staticPath) {
    const mapping = {};
    let slugIndex = 0;
    const pathItems = [];
    pathSpec.forEach(({ type, name })=>{
        switch(type){
            case 'literal':
                pathItems.push(name);
                break;
            case 'wildcard':
                mapping[name] = staticPath.slice(slugIndex);
                staticPath.slice(slugIndex++).forEach((slug)=>{
                    pathItems.push(slug);
                });
                break;
            case 'group':
                pathItems.push(staticPath[slugIndex++]);
                mapping[name] = pathItems[pathItems.length - 1];
                break;
        }
    });
    const definedPath = '/' + pathItems.join('/');
    return {
        definedPath,
        pathItems,
        mapping
    };
}

//# sourceMappingURL=create-pages.js.map