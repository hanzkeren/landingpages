{"version":3,"sources":["../../src/router/client.tsx"],"sourcesContent":["'use client';\n\nimport {\n  Component,\n  createContext,\n  startTransition,\n  use,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n  useTransition,\n} from 'react';\nimport type {\n  AnchorHTMLAttributes,\n  MouseEvent,\n  ReactElement,\n  ReactNode,\n  Ref,\n  RefObject,\n  TransitionFunction,\n} from 'react';\nimport { getErrorInfo } from '../lib/utils/custom-errors.js';\nimport { addBase, removeBase } from '../lib/utils/path.js';\nimport {\n  Root,\n  Slot,\n  prefetchRsc,\n  useElementsPromise_UNSTABLE as useElementsPromise,\n  useEnhanceFetchRscInternal_UNSTABLE as useEnhanceFetchRscInternal,\n  useRefetch,\n} from '../minimal/client.js';\nimport type { RouteConfig } from './base-types.js';\nimport {\n  HAS404_ID,\n  IS_STATIC_ID,\n  ROUTE_ID,\n  SKIP_HEADER,\n  encodeRoutePath,\n  encodeSliceId,\n} from './common.js';\nimport type { RouteProps } from './common.js';\n\ntype AllowPathDecorators<Path extends string> = Path extends unknown\n  ? Path | `${Path}?${string}` | `${Path}#${string}`\n  : never;\n\ntype InferredPaths = RouteConfig extends {\n  paths: infer UserPaths extends string;\n}\n  ? AllowPathDecorators<UserPaths>\n  : string;\n\nconst normalizeRoutePath = (path: string) => {\n  path = removeBase(path, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  for (const suffix of ['/', '/index.html']) {\n    if (path.endsWith(suffix)) {\n      return path.slice(0, -suffix.length) || '/';\n    }\n  }\n  return path;\n};\n\nconst parseRoute = (url: URL): RouteProps => {\n  const { pathname, searchParams, hash } = url;\n  return {\n    path: normalizeRoutePath(pathname),\n    query: searchParams.toString(),\n    hash,\n  };\n};\n\nconst getHttpStatusFromMeta = (): string | undefined => {\n  const httpStatusMeta = document.querySelector('meta[name=\"httpstatus\"]');\n  if (\n    httpStatusMeta &&\n    'content' in httpStatusMeta &&\n    typeof httpStatusMeta.content === 'string'\n  ) {\n    return httpStatusMeta.content;\n  }\n  return undefined;\n};\n\nconst parseRouteFromLocation = (): RouteProps => {\n  const httpStatus = getHttpStatusFromMeta();\n  if (httpStatus === '404') {\n    return { path: '/404', query: '', hash: '' };\n  }\n  return parseRoute(new URL(window.location.href));\n};\n\nconst isAltClick = (event: MouseEvent<HTMLAnchorElement>) =>\n  event.button !== 0 ||\n  !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n\nlet savedRscParams: [query: string, rscParams: URLSearchParams] | undefined;\n\nconst createRscParams = (query: string): URLSearchParams => {\n  if (savedRscParams && savedRscParams[0] === query) {\n    return savedRscParams[1];\n  }\n  const rscParams = new URLSearchParams({ query });\n  savedRscParams = [query, rscParams];\n  return rscParams;\n};\n\ntype ChangeRoute = (\n  route: RouteProps,\n  options: {\n    shouldScroll: boolean;\n    skipRefetch?: boolean;\n    unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;\n  },\n) => Promise<void>;\n\ntype ChangeRouteEvent = 'start' | 'complete';\n\ntype ChangeRouteCallback = (route: RouteProps) => void;\n\ntype PrefetchRoute = (route: RouteProps) => void;\n\ntype SliceId = string;\n\n// This is an internal thing, not a public API\nconst RouterContext = createContext<{\n  route: RouteProps;\n  changeRoute: ChangeRoute;\n  prefetchRoute: PrefetchRoute;\n  routeChangeEvents: Record<\n    'on' | 'off',\n    (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void\n  >;\n  fetchingSlices: Set<SliceId>;\n} | null>(null);\n\nexport function useRouter() {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n\n  const { route, changeRoute, prefetchRoute } = router;\n  const push = useCallback(\n    async (\n      to: InferredPaths,\n      options?: {\n        /**\n         * indicates if the link should scroll or not on navigation\n         * - `true`: always scroll\n         * - `false`: never scroll\n         * - `undefined`: scroll on path change (not on searchParams change)\n         */\n        scroll?: boolean;\n      },\n    ) => {\n      to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n      const url = new URL(to, window.location.href);\n      const currentPath = window.location.pathname;\n      const newPath = url.pathname !== currentPath;\n      await changeRoute(parseRoute(url), {\n        shouldScroll: options?.scroll ?? newPath,\n      });\n      if (window.location.pathname === currentPath) {\n        window.history.pushState(\n          {\n            ...window.history.state,\n            waku_new_path: newPath,\n          },\n          '',\n          url,\n        );\n      }\n    },\n    [changeRoute],\n  );\n  const replace = useCallback(\n    async (\n      to: InferredPaths,\n      options?: {\n        /**\n         * indicates if the link should scroll or not on navigation\n         * - `true`: always scroll\n         * - `false`: never scroll\n         * - `undefined`: scroll on path change (not on searchParams change)\n         */\n        scroll?: boolean;\n      },\n    ) => {\n      to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n      const url = new URL(to, window.location.href);\n      const currentPath = window.location.pathname;\n      const newPath = url.pathname !== currentPath;\n      await changeRoute(parseRoute(url), {\n        shouldScroll: options?.scroll ?? newPath,\n      });\n      if (window.location.pathname === currentPath) {\n        window.history.replaceState(window.history.state, '', url);\n      }\n    },\n    [changeRoute],\n  );\n  const reload = useCallback(async () => {\n    const url = new URL(window.location.href);\n    await changeRoute(parseRoute(url), { shouldScroll: true });\n  }, [changeRoute]);\n  const back = useCallback(() => {\n    // FIXME is this correct?\n    window.history.back();\n  }, []);\n  const forward = useCallback(() => {\n    // FIXME is this correct?\n    window.history.forward();\n  }, []);\n  const prefetch = useCallback(\n    (to: string) => {\n      const url = new URL(to, window.location.href);\n      prefetchRoute(parseRoute(url));\n    },\n    [prefetchRoute],\n  );\n  return {\n    ...route,\n    push,\n    replace,\n    reload,\n    back,\n    forward,\n    prefetch,\n    unstable_events: router.routeChangeEvents,\n  };\n}\n\nfunction useSharedRef<T>(\n  ref: Ref<T | null> | undefined,\n): [RefObject<T | null>, (node: T | null) => void | (() => void)] {\n  const managedRef = useRef<T>(null);\n\n  const handleRef = useCallback(\n    (node: T | null): void | (() => void) => {\n      managedRef.current = node;\n      const isRefCallback = typeof ref === 'function';\n      let cleanup: void | (() => void);\n      if (isRefCallback) {\n        cleanup = ref(node);\n      } else if (ref) {\n        // TODO is this a false positive?\n        // eslint-disable-next-line react-hooks/immutability\n        ref.current = node;\n      }\n      return () => {\n        managedRef.current = null;\n        if (isRefCallback) {\n          if (cleanup) {\n            cleanup();\n          } else {\n            ref(null);\n          }\n        } else if (ref) {\n          ref.current = null;\n        }\n      };\n    },\n    [ref],\n  );\n\n  return [managedRef, handleRef];\n}\n\nexport type LinkProps = {\n  to: InferredPaths;\n  children: ReactNode;\n  /**\n   * indicates if the link should scroll or not on navigation\n   * - `true`: always scroll\n   * - `false`: never scroll\n   * - `undefined`: scroll on path change (not on searchParams change)\n   */\n  scroll?: boolean;\n  unstable_pending?: ReactNode;\n  unstable_notPending?: ReactNode;\n  unstable_prefetchOnEnter?: boolean;\n  unstable_prefetchOnView?: boolean;\n  unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;\n  ref?: Ref<HTMLAnchorElement> | undefined;\n} & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;\n\nexport function Link({\n  to,\n  children,\n  scroll,\n  unstable_pending,\n  unstable_notPending,\n  unstable_prefetchOnEnter,\n  unstable_prefetchOnView,\n  unstable_startTransition,\n  ref: refProp,\n  ...props\n}: LinkProps): ReactElement {\n  to = addBase(to, import.meta.env.WAKU_CONFIG_BASE_PATH);\n  const router = useContext(RouterContext);\n  const changeRoute = router\n    ? router.changeRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const prefetchRoute = router\n    ? router.prefetchRoute\n    : () => {\n        throw new Error('Missing Router');\n      };\n  const [isPending, startTransition] = useTransition();\n  const startTransitionFn =\n    unstable_startTransition ||\n    ((unstable_pending || unstable_notPending) && startTransition) ||\n    ((fn: TransitionFunction) => fn());\n  const [ref, setRef] = useSharedRef<HTMLAnchorElement>(refProp);\n\n  useEffect(() => {\n    if (unstable_prefetchOnView && ref.current) {\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              const url = new URL(to, window.location.href);\n              if (router && url.href !== window.location.href) {\n                const route = parseRoute(url);\n                router.prefetchRoute(route);\n              }\n            }\n          });\n        },\n        { threshold: 0.1 },\n      );\n\n      observer.observe(ref.current);\n\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [unstable_prefetchOnView, router, to, ref]);\n  const internalOnClick = () => {\n    const url = new URL(to, window.location.href);\n    if (url.href !== window.location.href) {\n      const route = parseRoute(url);\n      prefetchRoute(route);\n      startTransitionFn(async () => {\n        const currentPath = window.location.pathname;\n        const newPath = url.pathname !== currentPath;\n        try {\n          await changeRoute(route, {\n            shouldScroll: scroll ?? newPath,\n            unstable_startTransition: startTransitionFn,\n          });\n        } finally {\n          if (window.location.pathname === currentPath) {\n            // Update history if it wasn't already updated\n            window.history.pushState(\n              {\n                ...window.history.state,\n                waku_new_path: newPath,\n              },\n              '',\n              url,\n            );\n          }\n        }\n      });\n    }\n  };\n  const onClick = (event: MouseEvent<HTMLAnchorElement>) => {\n    if (props.onClick) {\n      props.onClick(event);\n    }\n    if (!event.defaultPrevented && !isAltClick(event)) {\n      event.preventDefault();\n      internalOnClick();\n    }\n  };\n  const onMouseEnter = unstable_prefetchOnEnter\n    ? (event: MouseEvent<HTMLAnchorElement>) => {\n        const url = new URL(to, window.location.href);\n        if (url.href !== window.location.href) {\n          const route = parseRoute(url);\n          prefetchRoute(route);\n        }\n        props.onMouseEnter?.(event);\n      }\n    : props.onMouseEnter;\n  const ele = (\n    <a\n      {...props}\n      href={to}\n      onClick={onClick}\n      onMouseEnter={onMouseEnter}\n      ref={setRef}\n    >\n      {children}\n    </a>\n  );\n  if (isPending && unstable_pending !== undefined) {\n    return (\n      <>\n        {ele}\n        {unstable_pending}\n      </>\n    );\n  }\n  if (!isPending && unstable_notPending !== undefined) {\n    return (\n      <>\n        {ele}\n        {unstable_notPending}\n      </>\n    );\n  }\n  return ele;\n}\n\nconst notAvailableInServer = (name: string) => () => {\n  throw new Error(`${name} is not in the server`);\n};\n\nfunction renderError(message: string) {\n  return (\n    <html>\n      <head>\n        <title>Unhandled Error</title>\n      </head>\n      <body\n        style={{\n          height: '100vh',\n          display: 'flex',\n          flexDirection: 'column',\n          placeContent: 'center',\n          placeItems: 'center',\n          fontSize: '16px',\n          margin: 0,\n        }}\n      >\n        <h1>Caught an unexpected error</h1>\n        <p>Error: {message}</p>\n      </body>\n    </html>\n  );\n}\n\nexport class ErrorBoundary extends Component<\n  { children: ReactNode },\n  { error?: unknown }\n> {\n  constructor(props: { children: ReactNode }) {\n    super(props);\n    this.state = {};\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  render() {\n    if ('error' in this.state) {\n      if (this.state.error instanceof Error) {\n        return renderError(this.state.error.message);\n      }\n      return renderError(String(this.state.error));\n    }\n    return this.props.children;\n  }\n}\n\nconst NotFound = ({\n  has404,\n  reset,\n}: {\n  has404: boolean;\n  reset: () => void;\n}) => {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    if (has404) {\n      const url = new URL('/404', window.location.href);\n      changeRoute(parseRoute(url), { shouldScroll: true })\n        .then(() => {\n          // HACK: This timeout is required for canary-ci to work\n          // FIXME: As we understand it, we should have a proper solution.\n          setTimeout(() => {\n            reset();\n          }, 1);\n        })\n        .catch((err) => {\n          console.log('Error while navigating to 404:', err);\n        });\n    }\n  }, [has404, reset, changeRoute]);\n  return has404 ? null : <h1>Not Found</h1>;\n};\n\nconst Redirect = ({\n  error,\n  to,\n  reset,\n  handledErrorSet,\n}: {\n  error: unknown;\n  to: string;\n  reset: () => void;\n  handledErrorSet: WeakSet<object>;\n}) => {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { changeRoute } = router;\n  useEffect(() => {\n    // ensure single re-fetch per server redirection error on StrictMode\n    // https://github.com/wakujs/waku/pull/1512\n    if (handledErrorSet.has(error as object)) {\n      return;\n    }\n    handledErrorSet.add(error as object);\n\n    const url = new URL(to, window.location.href);\n    // FIXME this condition seems too naive\n    if (url.hostname !== window.location.hostname) {\n      window.location.replace(to);\n      return;\n    }\n    const currentPath = window.location.pathname;\n    const newPath = url.pathname !== currentPath;\n    changeRoute(parseRoute(url), { shouldScroll: newPath })\n      .then(() => {\n        // FIXME: As we understand it, we should have a proper solution.\n        setTimeout(() => {\n          reset();\n        }, 1);\n      })\n      .catch((err) => {\n        console.log('Error while navigating to redirect:', err);\n      })\n      .finally(() => {\n        if (window.location.pathname === currentPath) {\n          window.history.replaceState(\n            {\n              ...window.history.state,\n              waku_new_path: newPath,\n            },\n            '',\n            url,\n          );\n        }\n      });\n  }, [error, to, reset, changeRoute, handledErrorSet]);\n  return null;\n};\n\nclass CustomErrorHandler extends Component<\n  { has404: boolean; children?: ReactNode },\n  { error: unknown | null }\n> {\n  private handledErrorSet = new WeakSet();\n  constructor(props: { has404: boolean; children?: ReactNode }) {\n    super(props);\n    this.state = { error: null };\n    this.reset = this.reset.bind(this);\n  }\n  static getDerivedStateFromError(error: unknown) {\n    return { error };\n  }\n  reset() {\n    this.setState({ error: null });\n  }\n  render() {\n    const { error } = this.state;\n    if (error !== null) {\n      const info = getErrorInfo(error);\n      if (info?.status === 404) {\n        return <NotFound has404={this.props.has404} reset={this.reset} />;\n      }\n      if (info?.location) {\n        return (\n          <Redirect\n            error={error}\n            to={info.location}\n            reset={this.reset}\n            handledErrorSet={this.handledErrorSet}\n          />\n        );\n      }\n      throw error;\n    }\n    return this.props.children;\n  }\n}\n\nconst ThrowError = ({ error }: { error: unknown }) => {\n  throw error;\n};\n\nconst getRouteSlotId = (path: string) => 'route:' + decodeURI(path);\nconst getSliceSlotId = (id: SliceId) => 'slice:' + id;\n\nexport function Slice({\n  id,\n  children,\n  ...props\n}: {\n  id: SliceId;\n  children?: ReactNode;\n} & (\n  | {\n      lazy?: false;\n    }\n  | {\n      lazy: true;\n      fallback: ReactNode;\n    }\n)) {\n  const router = useContext(RouterContext);\n  if (!router) {\n    throw new Error('Missing Router');\n  }\n  const { fetchingSlices } = router;\n  const refetch = useRefetch();\n  const slotId = getSliceSlotId(id);\n  const elementsPromise = useElementsPromise();\n  const elements = use(elementsPromise);\n  const needsToFetchSlice =\n    props.lazy &&\n    (!(slotId in elements) ||\n      // FIXME: hard-coded for now\n      elements[IS_STATIC_ID + ':' + slotId] !== true);\n  useEffect(() => {\n    // FIXME this works because of subtle timing behavior.\n    if (needsToFetchSlice && !fetchingSlices.has(id)) {\n      fetchingSlices.add(id);\n      const rscPath = encodeSliceId(id);\n      refetch(rscPath)\n        .catch((e) => {\n          console.error('Failed to fetch slice:', e);\n        })\n        .finally(() => {\n          fetchingSlices.delete(id);\n        });\n    }\n  }, [fetchingSlices, refetch, id, needsToFetchSlice]);\n  if (props.lazy && !(slotId in elements)) {\n    // FIXME the fallback doesn't show on refetch after the first one.\n    return props.fallback;\n  }\n  return <Slot id={slotId}>{children}</Slot>;\n}\n\nconst handleScroll = () => {\n  const { hash } = window.location;\n  const { state } = window.history;\n  const element = hash && document.getElementById(hash.slice(1));\n  window.scrollTo({\n    left: 0,\n    top: element ? element.getBoundingClientRect().top + window.scrollY : 0,\n    behavior: state?.waku_new_path ? 'instant' : 'auto',\n  });\n};\n\nconst InnerRouter = ({\n  initialRoute,\n  httpStatus,\n}: {\n  initialRoute: RouteProps;\n  httpStatus: string | undefined;\n}) => {\n  if (import.meta.hot) {\n    const refetchRoute = () => {\n      staticPathSetRef.current.clear();\n      cachedIdSetRef.current.clear();\n      const rscPath = encodeRoutePath(route.path);\n      const rscParams = createRscParams(route.query);\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      refetch(rscPath, rscParams);\n    };\n    globalThis.__WAKU_RSC_RELOAD_LISTENERS__ ||= [];\n    const index = globalThis.__WAKU_RSC_RELOAD_LISTENERS__.indexOf(\n      globalThis.__WAKU_REFETCH_ROUTE__!,\n    );\n    if (index !== -1) {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.splice(index, 1, refetchRoute);\n    } else {\n      globalThis.__WAKU_RSC_RELOAD_LISTENERS__.unshift(refetchRoute);\n    }\n    globalThis.__WAKU_REFETCH_ROUTE__ = refetchRoute;\n  }\n\n  const elementsPromise = useElementsPromise();\n  const [has404, setHas404] = useState(false);\n  const requestedRouteRef = useRef<RouteProps>(initialRoute);\n  const staticPathSetRef = useRef(new Set<string>());\n  const cachedIdSetRef = useRef(new Set<string>());\n  useEffect(() => {\n    elementsPromise.then(\n      (elements) => {\n        const {\n          [ROUTE_ID]: routeData,\n          [IS_STATIC_ID]: isStatic,\n          [HAS404_ID]: has404FromElements,\n          ...rest\n        } = elements;\n        if (has404FromElements) {\n          setHas404(true);\n        }\n        if (routeData) {\n          const [path, _query] = routeData as [string, string];\n          if (isStatic) {\n            staticPathSetRef.current.add(path);\n          }\n        }\n        cachedIdSetRef.current = new Set(Object.keys(rest));\n      },\n      () => {},\n    );\n  }, [elementsPromise]);\n\n  const enhanceFetchRscInternal = useEnhanceFetchRscInternal();\n  const locationListenersRef = useRef(\n    new Set<(path: string, query: string) => void>(),\n  );\n  const locationListeners = locationListenersRef.current;\n  useEffect(() => {\n    const enhanceFetch =\n      (fetchFn: typeof fetch) =>\n      (input: RequestInfo | URL, init: RequestInit = {}) => {\n        const skipStr = JSON.stringify(Array.from(cachedIdSetRef.current));\n        const headers = (init.headers ||= {});\n        if (Array.isArray(headers)) {\n          headers.push([SKIP_HEADER, skipStr]);\n        } else {\n          (headers as Record<string, string>)[SKIP_HEADER] = skipStr;\n        }\n        return fetchFn(input, init);\n      };\n    return enhanceFetchRscInternal(\n      (fetchRscInternal) =>\n        (\n          rscPath: string,\n          rscParams: unknown,\n          prefetchOnly,\n          fetchFn = fetch,\n        ) => {\n          const enhancedFetch = enhanceFetch(fetchFn);\n          type Elements = Record<string, unknown>;\n          const elementsPromise = fetchRscInternal(\n            rscPath,\n            rscParams,\n            prefetchOnly as undefined,\n            enhancedFetch,\n          ) as Promise<Elements> | undefined;\n          Promise.resolve(elementsPromise)\n            .then((elements = {}) => {\n              const { [ROUTE_ID]: routeData, [IS_STATIC_ID]: isStatic } =\n                elements;\n              if (routeData) {\n                const [path, query] = routeData as [string, string];\n                if (\n                  requestedRouteRef.current.path !== path ||\n                  (!isStatic && requestedRouteRef.current.query !== query)\n                ) {\n                  locationListeners.forEach((listener) =>\n                    listener(path, query),\n                  );\n                }\n              }\n            })\n            .catch(() => {});\n          return elementsPromise as never;\n        },\n    );\n  }, [enhanceFetchRscInternal, locationListeners]);\n  const refetch = useRefetch();\n  const [route, setRoute] = useState(() => ({\n    // This is the first initialization of the route, and it has\n    // to ignore the hash, because on server side there is none.\n    // Otherwise there will be a hydration error.\n    // The client side route, including the hash, will be updated in the effect below.\n    ...initialRoute,\n    hash: '',\n  }));\n  const routeChangeListenersRef =\n    useRef<\n      [\n        Record<\n          'on' | 'off',\n          (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void\n        >,\n        (\n          eventType: ChangeRouteEvent,\n          eventRoute: Parameters<ChangeRouteCallback>[0],\n        ) => void,\n      ]\n    >(null);\n  if (routeChangeListenersRef.current === null) {\n    const listeners: Record<ChangeRouteEvent, Set<ChangeRouteCallback>> = {\n      start: new Set(),\n      complete: new Set(),\n    };\n    const executeListeners = (\n      eventType: ChangeRouteEvent,\n      eventRoute: Parameters<ChangeRouteCallback>[0],\n    ) => {\n      const eventListenersSet = listeners[eventType];\n      if (!eventListenersSet.size) {\n        return;\n      }\n      for (const listener of eventListenersSet) {\n        listener(eventRoute);\n      }\n    };\n    const events = (() => {\n      const on = (event: ChangeRouteEvent, handler: ChangeRouteCallback) => {\n        listeners[event].add(handler);\n      };\n      const off = (event: ChangeRouteEvent, handler: ChangeRouteCallback) => {\n        listeners[event].delete(handler);\n      };\n      return { on, off };\n    })();\n\n    routeChangeListenersRef.current = [events, executeListeners];\n  }\n  // Update the route post-load to include the current hash.\n  useEffect(() => {\n    setRoute((prev) => {\n      if (\n        prev.path === initialRoute.path &&\n        prev.query === initialRoute.query &&\n        prev.hash === initialRoute.hash\n      ) {\n        return prev;\n      }\n      return initialRoute;\n    });\n  }, [initialRoute]);\n\n  const [routeChangeEvents, executeListeners] = routeChangeListenersRef.current;\n  const [err, setErr] = useState<unknown>(null);\n  // FIXME this \"refetching\" hack doesn't seem ideal.\n  const refetching = useRef<[onFinish?: () => void] | null>(null);\n  const changeRoute: ChangeRoute = useCallback(\n    async (route, options) => {\n      requestedRouteRef.current = route;\n      executeListeners('start', route);\n      const startTransitionFn =\n        options.unstable_startTransition || ((fn: TransitionFunction) => fn());\n      refetching.current = [];\n      setErr(null);\n      const { skipRefetch } = options || {};\n      if (!staticPathSetRef.current.has(route.path) && !skipRefetch) {\n        const rscPath = encodeRoutePath(route.path);\n        const rscParams = createRscParams(route.query);\n        try {\n          await refetch(rscPath, rscParams);\n        } catch (e) {\n          refetching.current = null;\n          setErr(e);\n          throw e;\n        }\n      }\n      startTransitionFn(() => {\n        if (options.shouldScroll) {\n          handleScroll();\n        }\n        setRoute(route);\n        refetching.current![0]?.();\n        refetching.current = null;\n        executeListeners('complete', route);\n      });\n    },\n    [executeListeners, refetch],\n  );\n\n  const prefetchRoute: PrefetchRoute = useCallback((route) => {\n    if (staticPathSetRef.current.has(route.path)) {\n      return;\n    }\n    const rscPath = encodeRoutePath(route.path);\n    const rscParams = createRscParams(route.query);\n    prefetchRsc(rscPath, rscParams);\n    (globalThis as any).__WAKU_ROUTER_PREFETCH__?.(route.path);\n  }, []);\n\n  useEffect(() => {\n    const callback = () => {\n      const route = parseRoute(new URL(window.location.href));\n      changeRoute(route, { shouldScroll: true }).catch((err) => {\n        console.log('Error while navigating back:', err);\n      });\n    };\n    window.addEventListener('popstate', callback);\n    return () => {\n      window.removeEventListener('popstate', callback);\n    };\n  }, [changeRoute]);\n\n  useEffect(() => {\n    const callback = (path: string, query: string) => {\n      const fn = () => {\n        const url = new URL(window.location.href);\n        url.pathname = path;\n        url.search = query;\n        url.hash = '';\n        changeRoute(parseRoute(url), {\n          skipRefetch: true,\n          shouldScroll: false,\n        })\n          .catch((err) => {\n            console.log('Error while handling location listeners:', err);\n          })\n          .finally(() => {\n            if (path !== '/404') {\n              window.history.pushState(\n                {\n                  ...window.history.state,\n                  waku_new_path: url.pathname !== window.location.pathname,\n                },\n                '',\n                url,\n              );\n            }\n          });\n      };\n      if (refetching.current) {\n        refetching.current.push(fn);\n      } else {\n        startTransition(fn);\n      }\n    };\n    locationListeners.add(callback);\n    return () => {\n      locationListeners.delete(callback);\n    };\n  }, [changeRoute, locationListeners]);\n\n  const routeElement =\n    err !== null ? (\n      <ThrowError error={err} />\n    ) : (\n      <Slot id={getRouteSlotId(route.path)} />\n    );\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={httpStatus} />\n      <CustomErrorHandler has404={has404}>{routeElement}</CustomErrorHandler>\n    </Slot>\n  );\n  return (\n    <RouterContext\n      value={{\n        route,\n        changeRoute,\n        prefetchRoute,\n        routeChangeEvents,\n        fetchingSlices: useRef(new Set<SliceId>()).current,\n      }}\n    >\n      {rootElement}\n    </RouterContext>\n  );\n};\n\nexport function Router({\n  initialRoute = parseRouteFromLocation(),\n}: {\n  initialRoute?: RouteProps;\n}) {\n  const initialRscPath = encodeRoutePath(initialRoute.path);\n  const initialRscParams = createRscParams(initialRoute.query);\n  const httpStatus = getHttpStatusFromMeta();\n  return (\n    <Root initialRscPath={initialRscPath} initialRscParams={initialRscParams}>\n      <InnerRouter initialRoute={initialRoute} httpStatus={httpStatus} />\n    </Root>\n  );\n}\n\nconst MOCK_ROUTE_CHANGE_LISTENER: Record<\n  'on' | 'off',\n  (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void\n> = {\n  on: () => notAvailableInServer('routeChange:on'),\n  off: () => notAvailableInServer('routeChange:off'),\n};\n\n/**\n * ServerRouter for SSR\n * This is not a public API.\n */\nexport function INTERNAL_ServerRouter({\n  route,\n  httpstatus,\n}: {\n  route: RouteProps;\n  httpstatus: number;\n}) {\n  const routeElement = <Slot id={getRouteSlotId(route.path)} />;\n  const rootElement = (\n    <Slot id=\"root\">\n      <meta name=\"httpstatus\" content={`${httpstatus}`} />\n      {routeElement}\n    </Slot>\n  );\n  return (\n    <>\n      <RouterContext\n        value={{\n          route,\n          changeRoute: notAvailableInServer('changeRoute'),\n          prefetchRoute: notAvailableInServer('prefetchRoute'),\n          routeChangeEvents: MOCK_ROUTE_CHANGE_LISTENER,\n          fetchingSlices: new Set<SliceId>(),\n        }}\n      >\n        {rootElement}\n      </RouterContext>\n    </>\n  );\n}\n"],"names":["Component","createContext","startTransition","use","useCallback","useContext","useEffect","useRef","useState","useTransition","getErrorInfo","addBase","removeBase","Root","Slot","prefetchRsc","useElementsPromise_UNSTABLE","useElementsPromise","useEnhanceFetchRscInternal_UNSTABLE","useEnhanceFetchRscInternal","useRefetch","HAS404_ID","IS_STATIC_ID","ROUTE_ID","SKIP_HEADER","encodeRoutePath","encodeSliceId","normalizeRoutePath","path","env","WAKU_CONFIG_BASE_PATH","suffix","endsWith","slice","length","parseRoute","url","pathname","searchParams","hash","query","toString","getHttpStatusFromMeta","httpStatusMeta","document","querySelector","content","undefined","parseRouteFromLocation","httpStatus","URL","window","location","href","isAltClick","event","button","metaKey","altKey","ctrlKey","shiftKey","savedRscParams","createRscParams","rscParams","URLSearchParams","RouterContext","useRouter","router","Error","route","changeRoute","prefetchRoute","push","to","options","currentPath","newPath","shouldScroll","scroll","history","pushState","state","waku_new_path","replace","replaceState","reload","back","forward","prefetch","unstable_events","routeChangeEvents","useSharedRef","ref","managedRef","handleRef","node","current","isRefCallback","cleanup","Link","children","unstable_pending","unstable_notPending","unstable_prefetchOnEnter","unstable_prefetchOnView","unstable_startTransition","refProp","props","isPending","startTransitionFn","fn","setRef","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","threshold","observe","disconnect","internalOnClick","onClick","defaultPrevented","preventDefault","onMouseEnter","ele","a","notAvailableInServer","name","renderError","message","html","head","title","body","style","height","display","flexDirection","placeContent","placeItems","fontSize","margin","h1","p","ErrorBoundary","getDerivedStateFromError","error","render","String","NotFound","has404","reset","then","setTimeout","catch","err","console","log","Redirect","handledErrorSet","has","add","hostname","finally","CustomErrorHandler","WeakSet","bind","setState","info","status","ThrowError","getRouteSlotId","decodeURI","getSliceSlotId","id","Slice","fetchingSlices","refetch","slotId","elementsPromise","elements","needsToFetchSlice","lazy","rscPath","e","delete","fallback","handleScroll","element","getElementById","scrollTo","left","top","getBoundingClientRect","scrollY","behavior","InnerRouter","initialRoute","hot","refetchRoute","staticPathSetRef","clear","cachedIdSetRef","globalThis","__WAKU_RSC_RELOAD_LISTENERS__","index","indexOf","__WAKU_REFETCH_ROUTE__","splice","unshift","setHas404","requestedRouteRef","Set","routeData","isStatic","has404FromElements","rest","_query","Object","keys","enhanceFetchRscInternal","locationListenersRef","locationListeners","enhanceFetch","fetchFn","input","init","skipStr","JSON","stringify","Array","from","headers","isArray","fetchRscInternal","prefetchOnly","fetch","enhancedFetch","Promise","resolve","listener","setRoute","routeChangeListenersRef","listeners","start","complete","executeListeners","eventType","eventRoute","eventListenersSet","size","events","on","handler","off","prev","setErr","refetching","skipRefetch","__WAKU_ROUTER_PREFETCH__","callback","addEventListener","removeEventListener","search","routeElement","rootElement","meta","value","Router","initialRscPath","initialRscParams","MOCK_ROUTE_CHANGE_LISTENER","INTERNAL_ServerRouter","httpstatus"],"mappings":"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"}