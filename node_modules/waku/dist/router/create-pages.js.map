{"version":3,"sources":["../../src/router/create-pages.tsx"],"sourcesContent":["import { createElement } from 'react';\nimport type { FunctionComponent, ReactElement, ReactNode } from 'react';\nimport { getGrouplessPath } from '../lib/utils/create-pages.js';\nimport {\n  getPathMapping,\n  joinPath,\n  parseExactPath,\n  parsePathWithSlug,\n  pathSpecAsString,\n} from '../lib/utils/path.js';\nimport type { PathSpec } from '../lib/utils/path.js';\nimport { Children, Slot } from '../minimal/client.js';\nimport { ErrorBoundary } from '../router/client.js';\nimport type {\n  AnyPage,\n  GetSlugs,\n  PropsForPages,\n} from './create-pages-utils/inferred-path-types.js';\nimport { unstable_defineRouter } from './define-router.js';\n\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods\nexport const METHODS = [\n  'GET',\n  'HEAD',\n  'POST',\n  'PUT',\n  'DELETE',\n  'CONNECT',\n  'OPTIONS',\n  'TRACE',\n  'PATCH',\n] as const;\nexport type Method = (typeof METHODS)[number];\n\nexport const pathMappingWithoutGroups: typeof getPathMapping = (\n  pathSpec,\n  pathname,\n) => {\n  const cleanPathSpec = pathSpec.filter(\n    (spec) => !(spec.type === 'literal' && spec.name.startsWith('(')),\n  );\n  return getPathMapping(cleanPathSpec, pathname);\n};\n\nconst sanitizeSlug = (slug: string) => slug.replace(/ /g, '-');\n\n// createPages API (a wrapper around unstable_defineRouter)\n\n/** Assumes that the path is a part of a slug path. */\ntype IsValidPathItem<T> = T extends `/${string}` | '[]' | '' ? false : true;\n/**\n * This is a helper type to check if a path is valid in a slug path.\n */\nexport type IsValidPathInSlugPath<T> = T extends `/${infer L}/${infer R}`\n  ? IsValidPathItem<L> extends true\n    ? IsValidPathInSlugPath<`/${R}`>\n    : false\n  : T extends `/${infer U}`\n    ? IsValidPathItem<U>\n    : false;\n/** Checks if a particular slug name exists in a path. */\nexport type HasSlugInPath<T, K extends string> = T extends `/[${K}]/${infer _}`\n  ? true\n  : T extends `/${infer _}/${infer U}`\n    ? HasSlugInPath<`/${U}`, K>\n    : T extends `/[${K}]`\n      ? true\n      : false;\n\nexport type HasWildcardInPath<T> = T extends `/[...${string}]/${string}`\n  ? true\n  : T extends `/${infer _}/${infer U}`\n    ? HasWildcardInPath<`/${U}`>\n    : T extends `/[...${string}]`\n      ? true\n      : false;\n\nexport type PathWithSlug<T, K extends string> =\n  IsValidPathInSlugPath<T> extends true\n    ? HasSlugInPath<T, K> extends true\n      ? T\n      : never\n    : never;\n\nexport type StaticSlugRoutePathsTuple<\n  T extends string,\n  Slugs extends unknown[] = GetSlugs<T>,\n  Result extends readonly string[] = [],\n> = Slugs extends []\n  ? Result\n  : Slugs extends [infer _, ...infer Rest]\n    ? StaticSlugRoutePathsTuple<T, Rest, readonly [...Result, string]>\n    : never;\n\ntype StaticSlugRoutePaths<T extends string> =\n  HasWildcardInPath<T> extends true\n    ? readonly string[] | readonly string[][]\n    : StaticSlugRoutePathsTuple<T> extends readonly [string]\n      ? readonly string[]\n      : StaticSlugRoutePathsTuple<T>[];\n\n/** Remove Slug from Path */\nexport type PathWithoutSlug<T> = T extends '/'\n  ? T\n  : IsValidPathInSlugPath<T> extends true\n    ? HasSlugInPath<T, string> extends true\n      ? never\n      : T\n    : never;\n\ntype PathWithStaticSlugs<T extends string> = T extends `/`\n  ? T\n  : IsValidPathInSlugPath<T> extends true\n    ? T\n    : never;\n\nexport type PathWithWildcard<\n  Path,\n  SlugKey extends string,\n  WildSlugKey extends string,\n> = PathWithSlug<Path, SlugKey | `...${WildSlugKey}`>;\n\nexport type CreatePage = <\n  Path extends string,\n  SlugKey extends string,\n  WildSlugKey extends string,\n  Render extends 'static' | 'dynamic',\n  StaticPaths extends StaticSlugRoutePaths<Path>,\n  ExactPath extends boolean | undefined = undefined,\n  Slices extends string[] = [],\n>(\n  page: (\n    | {\n        render: Extract<Render, 'static'>;\n        path: PathWithoutSlug<Path>;\n        component: FunctionComponent<PropsForPages<Path>>;\n      }\n    | ({\n        render: Extract<Render, 'static'>;\n        path: PathWithStaticSlugs<Path>;\n        component: FunctionComponent<PropsForPages<Path>>;\n      } & (ExactPath extends true ? {} : { staticPaths: StaticPaths }))\n    | {\n        render: Extract<Render, 'dynamic'>;\n        path: PathWithoutSlug<Path>;\n        component: FunctionComponent<PropsForPages<Path>>;\n      }\n    | {\n        render: Extract<Render, 'dynamic'>;\n        path: PathWithWildcard<Path, SlugKey, WildSlugKey>;\n        component: FunctionComponent<PropsForPages<Path>>;\n      }\n  ) & {\n    unstable_disableSSR?: boolean;\n    /**\n     * If true, the path will be matched exactly, without wildcards or slugs.\n     * This is intended for extending support to create custom routers.\n     */\n    exactPath?: ExactPath;\n    /**\n     * List of slice ids used in the component.\n     * This is _required_ to send the slices along with the component.\n     */\n    slices?: Slices;\n  },\n) => Omit<\n  Exclude<typeof page, { path: never } | { render: never }>,\n  'unstable_disableSSR'\n>;\n\nexport type CreateLayout = <Path extends string>(\n  layout:\n    | {\n        render: 'dynamic';\n        path: Path;\n        component: FunctionComponent<{ children: ReactNode }>;\n      }\n    | {\n        render: 'static';\n        path: Path;\n        component: FunctionComponent<{ children: ReactNode }>;\n      },\n) => void;\n\ntype ApiHandler = (req: Request) => Promise<Response>;\n\nexport type CreateApi = <Path extends string>(\n  params:\n    | {\n        render: 'static';\n        path: Path;\n        method: 'GET';\n        handler: ApiHandler;\n        staticPaths?: (string | string[])[] | undefined;\n      }\n    | {\n        render: 'dynamic';\n        path: Path;\n        /**\n         * Handlers by named method. Use `all` to handle all methods.\n         * Named methods will take precedence over `all`.\n         */\n        handlers: Partial<Record<Method | 'all', ApiHandler>>;\n      },\n) => void;\n\nexport type CreateSlice = <ID extends string>(slice: {\n  render: 'static' | 'dynamic';\n  id: ID;\n  component: FunctionComponent<{ children: ReactNode }>;\n}) => void;\n\ntype RootItem = {\n  render: 'static' | 'dynamic';\n  component: FunctionComponent<{ children: ReactNode }>;\n};\n\nexport type CreateRoot = (root: RootItem) => void;\n\n/**\n * Root component for all pages\n * ```tsx\n *   <html>\n *     <head></head>\n *     <body>{children}</body>\n *   </html>\n * ```\n */\nconst DefaultRoot = ({ children }: { children: ReactNode }) => (\n  <ErrorBoundary>\n    <html>\n      <head />\n      <body>{children}</body>\n    </html>\n  </ErrorBoundary>\n);\n\nconst createNestedElements = (\n  elements: {\n    component: FunctionComponent<any>;\n    props?: Record<string, unknown>;\n  }[],\n  children: ReactElement,\n): ReactElement =>\n  elements.reduceRight(\n    (result, element) =>\n      createElement(element.component, element.props, result),\n    children,\n  );\n\ntype ComponentList = {\n  render: 'static' | 'dynamic';\n  component: FunctionComponent<any>;\n}[];\n\ntype ComponentEntry = FunctionComponent<any> | ComponentList;\n\nconst routePriorityComparator = (\n  a: {\n    path: PathSpec;\n    type: 'route' | 'api';\n  },\n  b: {\n    path: PathSpec;\n    type: 'route' | 'api';\n  },\n) => {\n  const aPath = a.path;\n  const bPath = b.path;\n  const aPathLength = aPath.length;\n  const bPathLength = bPath.length;\n  const aHasWildcard = aPath.at(-1)?.type === 'wildcard';\n  const bHasWildcard = bPath.at(-1)?.type === 'wildcard';\n\n  // Special case: root route (length 0) should come before wildcard routes\n  // This ensures exact matches like \"/\" are checked before catch-all routes like \"/[...notFound]\"\n  if (aPathLength === 0 && bHasWildcard) {\n    return -1;\n  }\n  if (bPathLength === 0 && aHasWildcard) {\n    return 1;\n  }\n\n  // Compare path lengths first (longer paths are more specific)\n  if (aPathLength !== bPathLength) {\n    return aPathLength > bPathLength ? -1 : 1;\n  }\n\n  // If path lengths are equal, compare wildcard presence\n  // sort the route without the wildcard higher, to check it earlier\n  if (aHasWildcard !== bHasWildcard) {\n    return aHasWildcard ? 1 : -1;\n  }\n\n  // If all else is equal, routes have the same priority\n  return 0;\n};\n\nexport const createPages = <\n  AllPages extends (AnyPage | ReturnType<CreateLayout>)[],\n>(\n  fn: (fns: {\n    createPage: CreatePage;\n    createLayout: CreateLayout;\n    createRoot: CreateRoot;\n    createApi: CreateApi;\n    createSlice: CreateSlice;\n  }) => Promise<AllPages>,\n) => {\n  let configured = false;\n\n  // layout lookups retain (group) path and pathMaps store without group\n  // paths are stored without groups to easily detect duplicates\n  const groupPathLookup = new Map<string, string>();\n  const staticPathMap = new Map<\n    string,\n    { literalSpec: PathSpec; originalSpec?: PathSpec }\n  >();\n  const dynamicPagePathMap = new Map<string, [PathSpec, ComponentEntry]>();\n  const wildcardPagePathMap = new Map<string, [PathSpec, ComponentEntry]>();\n  const dynamicLayoutPathMap = new Map<string, [PathSpec, ComponentEntry]>();\n  const apiPathMap = new Map<\n    string, // `${method} ${path}`\n    {\n      render: 'static' | 'dynamic';\n      pathSpec: PathSpec;\n      handlers: Partial<Record<Method | 'all', ApiHandler>>;\n    }\n  >();\n  const staticComponentMap = new Map<string, FunctionComponent<any>>();\n  const getStaticLayout = (id: string) =>\n    staticComponentMap.get(joinPath(id, 'layout').slice(1));\n  const getDynamicLayout = (segment: string) =>\n    dynamicLayoutPathMap.get(segment)?.[1];\n  const slicePathMap = new Map<string, string[]>();\n  const sliceIdMap = new Map<\n    string,\n    {\n      component: FunctionComponent<any>;\n      isStatic: boolean;\n    }\n  >();\n  let rootItem: RootItem | undefined = undefined;\n  const noSsrSet = new WeakSet<PathSpec>();\n\n  const pagePathExists = (path: string) => {\n    for (const pathKey of apiPathMap.keys()) {\n      const [_m, p] = pathKey.split(' ');\n      if (p === path) {\n        return true;\n      }\n    }\n    return (\n      staticPathMap.has(path) ||\n      dynamicPagePathMap.has(path) ||\n      wildcardPagePathMap.has(path)\n    );\n  };\n\n  /** Creates a function to map pathname to component props */\n  const createPathPropsMapper = (path: string) => {\n    const layoutMatchPath = groupPathLookup.get(path) ?? path;\n    const pathSpec = parsePathWithSlug(layoutMatchPath);\n    return (pathname: string) =>\n      pathMappingWithoutGroups(pathSpec, encodeURI(pathname));\n  };\n\n  /** Builds the routeElement renderer from layouts and page slots */\n  const buildRouteElement = (\n    layoutPaths: string[],\n    path: string,\n    pageComponent: ComponentEntry,\n  ) => {\n    const layouts = layoutPaths.map((lPath) => ({\n      component: Slot,\n      props: { id: `layout:${lPath}` },\n    }));\n    const finalPageChildren = Array.isArray(pageComponent) ? (\n      <>\n        {pageComponent.map((_comp, order) => (\n          <Slot id={`page:${path}:${order}`} key={`page:${path}:${order}`} />\n        ))}\n      </>\n    ) : (\n      <Slot id={`page:${path}`} />\n    );\n    return () => createNestedElements(layouts, finalPageChildren);\n  };\n\n  /** Renders the root component */\n  const renderRoot = () =>\n    createElement(\n      rootItem ? rootItem.component : DefaultRoot,\n      null,\n      <Children />,\n    );\n\n  const registerStaticComponent = (\n    id: string,\n    component: FunctionComponent<any>,\n  ) => {\n    if (\n      staticComponentMap.has(id) &&\n      staticComponentMap.get(id) !== component\n    ) {\n      throw new Error(`Duplicated component for: ${id}`);\n    }\n    staticComponentMap.set(id, component);\n  };\n\n  const isAllElementsStatic = (\n    elements: Record<string, { isStatic?: boolean }>,\n  ) => Object.values(elements).every((element) => element.isStatic);\n\n  const isAllSlicesStatic = (path: string) =>\n    (slicePathMap.get(path) || []).every(\n      (sliceId) => sliceIdMap.get(sliceId)?.isStatic,\n    );\n\n  const createPage: CreatePage = (page) => {\n    if (configured) {\n      throw new Error('createPage no longer available');\n    }\n    if (pagePathExists(page.path)) {\n      throw new Error(`Duplicated path: ${page.path}`);\n    }\n\n    const pathSpec = parsePathWithSlug(page.path);\n    const { numSlugs, numWildcards } = getSlugsAndWildcards(pathSpec);\n    if (page.unstable_disableSSR) {\n      noSsrSet.add(pathSpec);\n    }\n\n    if (page.exactPath) {\n      const spec = parseExactPath(page.path);\n      if (page.render === 'static') {\n        staticPathMap.set(page.path, {\n          literalSpec: spec,\n        });\n        const id = joinPath(page.path, 'page').replace(/^\\//, '');\n        if (page.component) {\n          registerStaticComponent(id, page.component);\n        }\n      } else if (page.component) {\n        dynamicPagePathMap.set(page.path, [spec, page.component]);\n      } else {\n        dynamicPagePathMap.set(page.path, [spec, []]);\n      }\n    } else if (page.render === 'static' && numSlugs === 0) {\n      const pagePath = getGrouplessPath(page.path);\n      staticPathMap.set(pagePath, {\n        literalSpec: pathSpec,\n      });\n      const id = joinPath(pagePath, 'page').replace(/^\\//, '');\n      if (pagePath !== page.path) {\n        groupPathLookup.set(pagePath, page.path);\n      }\n      if (page.component) {\n        registerStaticComponent(id, page.component);\n      }\n    } else if (\n      page.render === 'static' &&\n      numSlugs > 0 &&\n      'staticPaths' in page\n    ) {\n      const staticPaths = page.staticPaths.map((item) =>\n        (Array.isArray(item) ? item : [item]).map(sanitizeSlug),\n      );\n      for (const staticPath of staticPaths) {\n        if (staticPath.length !== numSlugs && numWildcards === 0) {\n          throw new Error('staticPaths does not match with slug pattern');\n        }\n        const { definedPath, pathItems, mapping } = expandStaticPathSpec(\n          pathSpec,\n          staticPath,\n        );\n        const pagePath = getGrouplessPath(definedPath);\n        staticPathMap.set(pagePath, {\n          literalSpec: pathItems.map((name) => ({ type: 'literal', name })),\n          originalSpec: pathSpec,\n        });\n        if (pagePath !== definedPath) {\n          groupPathLookup.set(pagePath, definedPath);\n        }\n        const id = joinPath(pagePath, 'page').replace(/^\\//, '');\n        const WrappedComponent = (props: Record<string, unknown>) =>\n          createElement(page.component as any, { ...props, ...mapping });\n        registerStaticComponent(id, WrappedComponent);\n      }\n    } else if (page.render === 'dynamic' && numWildcards === 0) {\n      const pagePath = getGrouplessPath(page.path);\n      if (pagePath !== page.path) {\n        groupPathLookup.set(pagePath, page.path);\n      }\n      dynamicPagePathMap.set(pagePath, [pathSpec, page.component]);\n    } else if (page.render === 'dynamic' && numWildcards === 1) {\n      const pagePath = getGrouplessPath(page.path);\n      if (pagePath !== page.path) {\n        groupPathLookup.set(pagePath, page.path);\n      }\n      wildcardPagePathMap.set(pagePath, [pathSpec, page.component]);\n    } else {\n      throw new Error('Invalid page configuration ' + JSON.stringify(page));\n    }\n    if (page.slices?.length) {\n      slicePathMap.set(page.path, page.slices);\n    }\n    return page as Exclude<typeof page, { path: never } | { render: never }>;\n  };\n\n  const createLayout: CreateLayout = (layout) => {\n    if (configured) {\n      throw new Error('createLayout no longer available');\n    }\n    if (layout.render === 'static') {\n      const id = joinPath(layout.path, 'layout').replace(/^\\//, '');\n      registerStaticComponent(id, layout.component);\n    } else if (layout.render === 'dynamic') {\n      if (dynamicLayoutPathMap.has(layout.path)) {\n        throw new Error(`Duplicated dynamic path: ${layout.path}`);\n      }\n      const pathSpec = parsePathWithSlug(layout.path);\n      dynamicLayoutPathMap.set(layout.path, [pathSpec, layout.component]);\n    } else {\n      throw new Error('Invalid layout configuration');\n    }\n  };\n\n  const createApi: CreateApi = (options) => {\n    if (configured) {\n      throw new Error('createApi no longer available');\n    }\n    if (apiPathMap.has(options.path)) {\n      throw new Error(`Duplicated api path: ${options.path}`);\n    }\n    const pathSpec = parsePathWithSlug(options.path);\n    if (options.render === 'static') {\n      const { numSlugs, numWildcards } = getSlugsAndWildcards(pathSpec);\n      if (numSlugs > 0 && options.staticPaths) {\n        const staticPaths = options.staticPaths.map((item) =>\n          (Array.isArray(item) ? item : [item]).map(sanitizeSlug),\n        );\n        for (const staticPath of staticPaths) {\n          if (staticPath.length !== numSlugs && numWildcards === 0) {\n            throw new Error('staticPaths does not match with slug pattern');\n          }\n          const { definedPath, pathItems } = expandStaticPathSpec(\n            pathSpec,\n            staticPath,\n          );\n          if (apiPathMap.has(definedPath)) {\n            throw new Error(`Duplicated api path: ${definedPath}`);\n          }\n          apiPathMap.set(definedPath, {\n            render: 'static',\n            pathSpec: pathItems.map((name) => ({ type: 'literal', name })),\n            handlers: { GET: options.handler },\n          });\n        }\n      } else {\n        apiPathMap.set(options.path, {\n          render: 'static',\n          pathSpec,\n          handlers: { GET: options.handler },\n        });\n      }\n    } else {\n      apiPathMap.set(options.path, {\n        render: 'dynamic',\n        pathSpec,\n        handlers: options.handlers,\n      });\n    }\n  };\n\n  const createRoot: CreateRoot = (root) => {\n    if (configured) {\n      throw new Error('createRoot no longer available');\n    }\n    if (rootItem) {\n      throw new Error(`Duplicated root component`);\n    }\n    if (root.render === 'static' || root.render === 'dynamic') {\n      rootItem = root;\n    } else {\n      throw new Error('Invalid root configuration');\n    }\n  };\n\n  const createSlice: CreateSlice = (slice) => {\n    if (configured) {\n      throw new Error('createSlice no longer available');\n    }\n    if (sliceIdMap.has(slice.id)) {\n      throw new Error(`Duplicated slice id: ${slice.id}`);\n    }\n    sliceIdMap.set(slice.id, {\n      component: slice.component,\n      isStatic: slice.render === 'static',\n    });\n  };\n\n  let ready: Promise<AllPages | void> | undefined;\n  const configure = async () => {\n    if (!configured && !ready) {\n      ready = fn({\n        createPage,\n        createLayout,\n        createRoot,\n        createApi,\n        createSlice,\n      });\n      await ready;\n\n      configured = true;\n    }\n    await ready;\n  };\n\n  const getLayouts = (spec: PathSpec): string[] => {\n    const pathSegments = spec.reduce<string[]>(\n      (acc, _segment, index) => {\n        acc.push(pathSpecAsString(spec.slice(0, index + 1)));\n        return acc;\n      },\n      ['/'],\n    );\n\n    return pathSegments.filter(\n      (segment) =>\n        dynamicLayoutPathMap.has(segment) || getStaticLayout(segment),\n    );\n  };\n\n  const definedRouter = unstable_defineRouter({\n    getConfigs: async () => {\n      await configure();\n      type ElementSpec = {\n        isStatic: boolean;\n        renderer: (options: {\n          pathname: string;\n          query: string | undefined;\n        }) => ReactNode;\n      };\n      const routeConfigs: {\n        type: 'route';\n        path: PathSpec;\n        isStatic: boolean;\n        pathPattern?: PathSpec;\n        rootElement: ElementSpec;\n        routeElement: ElementSpec;\n        elements: Record<string, ElementSpec>;\n        noSsr: boolean;\n        slices: string[];\n      }[] = [];\n      const rootIsStatic = !rootItem || rootItem.render === 'static';\n      for (const [path, { literalSpec, originalSpec }] of staticPathMap) {\n        const noSsr = noSsrSet.has(literalSpec);\n        const layoutPaths = getLayouts(originalSpec ?? literalSpec);\n        const pageComponent = staticComponentMap.get(\n          joinPath(path, 'page').slice(1),\n        )!;\n        const getPropsMapping = createPathPropsMapper(path);\n\n        const elements: Record<string, ElementSpec> = {};\n\n        // Add layout elements\n        for (const lPath of layoutPaths) {\n          const layout = getDynamicLayout(lPath) ?? getStaticLayout(lPath);\n          if (!layout || Array.isArray(layout)) {\n            throw new Error('Invalid layout ' + lPath);\n          }\n          elements[`layout:${lPath}`] = {\n            isStatic: !dynamicLayoutPathMap.has(lPath),\n            renderer: () => createElement(layout, null, <Children />),\n          };\n        }\n\n        // Add page element\n        elements[`page:${path}`] = {\n          isStatic: true,\n          renderer: (option) =>\n            createElement(\n              pageComponent,\n              {\n                ...getPropsMapping(option.pathname),\n                ...(option.query ? { query: option.query } : {}),\n                path: option.pathname,\n              },\n              <Children />,\n            ),\n        };\n\n        routeConfigs.push({\n          type: 'route',\n          path: literalSpec.filter((part) => !part.name?.startsWith('(')),\n          isStatic:\n            rootIsStatic &&\n            isAllElementsStatic(elements) &&\n            isAllSlicesStatic(path),\n          ...(originalSpec && { pathPattern: originalSpec }),\n          rootElement: { isStatic: rootIsStatic, renderer: renderRoot },\n          routeElement: {\n            isStatic: true,\n            renderer: buildRouteElement(layoutPaths, path, pageComponent),\n          },\n          elements,\n          noSsr,\n          slices: slicePathMap.get(path) || [],\n        });\n      }\n      for (const [path, [pathSpec, components]] of dynamicPagePathMap) {\n        const noSsr = noSsrSet.has(pathSpec);\n        const layoutPaths = getLayouts(pathSpec);\n        const getPropsMapping = createPathPropsMapper(path);\n\n        const elements: Record<string, ElementSpec> = {};\n\n        // Add layout elements\n        for (const lPath of layoutPaths) {\n          const layout = getDynamicLayout(lPath) ?? getStaticLayout(lPath);\n          if (!layout || Array.isArray(layout)) {\n            throw new Error('Invalid layout ' + lPath);\n          }\n          elements[`layout:${lPath}`] = {\n            isStatic: !dynamicLayoutPathMap.has(lPath),\n            renderer: () => createElement(layout, null, <Children />),\n          };\n        }\n\n        // Add page elements\n        if (Array.isArray(components)) {\n          for (let i = 0; i < components.length; i++) {\n            const comp = components[i];\n            if (comp) {\n              elements[`page:${path}:${i}`] = {\n                isStatic: comp.render === 'static',\n                renderer: (option) =>\n                  createElement(comp.component, {\n                    ...getPropsMapping(option.pathname),\n                    ...(option.query ? { query: option.query } : {}),\n                    path: option.pathname,\n                  }),\n              };\n            }\n          }\n        } else {\n          elements[`page:${path}`] = {\n            isStatic: false,\n            renderer: (option) =>\n              createElement(\n                components,\n                {\n                  ...getPropsMapping(option.pathname),\n                  ...(option.query ? { query: option.query } : {}),\n                  path: option.pathname,\n                },\n                <Children />,\n              ),\n          };\n        }\n\n        routeConfigs.push({\n          type: 'route',\n          isStatic:\n            rootIsStatic &&\n            isAllElementsStatic(elements) &&\n            isAllSlicesStatic(path),\n          path: pathSpec.filter((part) => !part.name?.startsWith('(')),\n          rootElement: { isStatic: rootIsStatic, renderer: renderRoot },\n          routeElement: {\n            isStatic: true,\n            renderer: buildRouteElement(layoutPaths, path, components),\n          },\n          elements,\n          noSsr,\n          slices: slicePathMap.get(path) || [],\n        });\n      }\n      for (const [path, [pathSpec, components]] of wildcardPagePathMap) {\n        const noSsr = noSsrSet.has(pathSpec);\n        const layoutPaths = getLayouts(pathSpec);\n        const getPropsMapping = createPathPropsMapper(path);\n\n        const elements: Record<string, ElementSpec> = {};\n\n        // Add layout elements\n        for (const lPath of layoutPaths) {\n          const layout = getDynamicLayout(lPath) ?? getStaticLayout(lPath);\n          if (!layout || Array.isArray(layout)) {\n            throw new Error('Invalid layout ' + lPath);\n          }\n          elements[`layout:${lPath}`] = {\n            isStatic: !dynamicLayoutPathMap.has(lPath),\n            renderer: () => createElement(layout, null, <Children />),\n          };\n        }\n\n        // Add page elements\n        if (Array.isArray(components)) {\n          for (let i = 0; i < components.length; i++) {\n            const comp = components[i];\n            if (comp) {\n              elements[`page:${path}:${i}`] = {\n                isStatic: comp.render === 'static',\n                renderer: (option) =>\n                  createElement(comp.component, {\n                    ...getPropsMapping(option.pathname),\n                    ...(option.query ? { query: option.query } : {}),\n                    path: option.pathname,\n                  }),\n              };\n            }\n          }\n        } else {\n          elements[`page:${path}`] = {\n            isStatic: false,\n            renderer: (option) =>\n              createElement(\n                components,\n                {\n                  ...getPropsMapping(option.pathname),\n                  ...(option.query ? { query: option.query } : {}),\n                  path: option.pathname,\n                },\n                <Children />,\n              ),\n          };\n        }\n\n        routeConfigs.push({\n          type: 'route',\n          isStatic:\n            rootIsStatic &&\n            isAllElementsStatic(elements) &&\n            isAllSlicesStatic(path),\n          path: pathSpec.filter((part) => !part.name?.startsWith('(')),\n          rootElement: { isStatic: rootIsStatic, renderer: renderRoot },\n          routeElement: {\n            isStatic: true,\n            renderer: buildRouteElement(layoutPaths, path, components),\n          },\n          elements,\n          noSsr,\n          slices: slicePathMap.get(path) || [],\n        });\n      }\n      const apiConfigs = Array.from(apiPathMap.values()).map(\n        ({ pathSpec, render, handlers }) => {\n          return {\n            type: 'api' as const,\n            path: pathSpec,\n            isStatic: render === 'static',\n            handler: async (req: Request) => {\n              const path = new URL(req.url).pathname;\n              const method = req.method;\n              const handler = handlers[method as Method] ?? handlers.all;\n              if (!handler) {\n                throw new Error(\n                  'API method not found: ' + method + 'for path: ' + path,\n                );\n              }\n              return handler(req);\n            },\n          };\n        },\n      );\n\n      const sliceConfigs = Array.from(sliceIdMap).map(([id, { isStatic }]) => ({\n        type: 'slice' as const,\n        id,\n        isStatic,\n        renderer: async () => {\n          const slice = sliceIdMap.get(id);\n          if (!slice) {\n            throw new Error('Slice not found: ' + id);\n          }\n          return <slice.component />;\n        },\n      }));\n\n      const pathConfigs = [...routeConfigs, ...apiConfigs]\n        // Sort routes by priority: \"standard routes\" -> api routes -> api wildcard routes -> standard wildcard routes\n        .sort((configA, configB) => routePriorityComparator(configA, configB));\n      return [...pathConfigs, ...sliceConfigs];\n    },\n  });\n\n  return definedRouter as typeof definedRouter & {\n    /** This for type inference of the router only. We do not actually return anything for this type. */\n    DO_NOT_USE_pages: Exclude<\n      Exclude<Awaited<Exclude<typeof ready, undefined>>, void>[number],\n      void // createLayout returns void\n    >;\n  };\n};\n\nconst getSlugsAndWildcards = (pathSpec: PathSpec) => {\n  let numSlugs = 0;\n  let numWildcards = 0;\n  for (const slug of pathSpec) {\n    if (slug.type !== 'literal') {\n      numSlugs++;\n    }\n    if (slug.type === 'wildcard') {\n      numWildcards++;\n    }\n  }\n  return { numSlugs, numWildcards };\n};\n\nfunction expandStaticPathSpec(pathSpec: PathSpec, staticPath: string[]) {\n  const mapping: Record<string, string | string[]> = {};\n  let slugIndex = 0;\n  const pathItems: string[] = [];\n  pathSpec.forEach(({ type, name }) => {\n    switch (type) {\n      case 'literal':\n        pathItems.push(name!);\n        break;\n      case 'wildcard':\n        mapping[name!] = staticPath.slice(slugIndex);\n        staticPath.slice(slugIndex++).forEach((slug) => {\n          pathItems.push(slug);\n        });\n        break;\n      case 'group':\n        pathItems.push(staticPath[slugIndex++]!);\n        mapping[name!] = pathItems[pathItems.length - 1]!;\n        break;\n    }\n  });\n  const definedPath = '/' + pathItems.join('/');\n  return {\n    definedPath,\n    pathItems,\n    mapping,\n  };\n}\n"],"names":["createElement","getGrouplessPath","getPathMapping","joinPath","parseExactPath","parsePathWithSlug","pathSpecAsString","Children","Slot","ErrorBoundary","unstable_defineRouter","METHODS","pathMappingWithoutGroups","pathSpec","pathname","cleanPathSpec","filter","spec","type","name","startsWith","sanitizeSlug","slug","replace","DefaultRoot","children","html","head","body","createNestedElements","elements","reduceRight","result","element","component","props","routePriorityComparator","a","b","aPath","path","bPath","aPathLength","length","bPathLength","aHasWildcard","at","bHasWildcard","createPages","fn","configured","groupPathLookup","Map","staticPathMap","dynamicPagePathMap","wildcardPagePathMap","dynamicLayoutPathMap","apiPathMap","staticComponentMap","getStaticLayout","id","get","slice","getDynamicLayout","segment","slicePathMap","sliceIdMap","rootItem","undefined","noSsrSet","WeakSet","pagePathExists","pathKey","keys","_m","p","split","has","createPathPropsMapper","layoutMatchPath","encodeURI","buildRouteElement","layoutPaths","pageComponent","layouts","map","lPath","finalPageChildren","Array","isArray","_comp","order","renderRoot","registerStaticComponent","Error","set","isAllElementsStatic","Object","values","every","isStatic","isAllSlicesStatic","sliceId","createPage","page","numSlugs","numWildcards","getSlugsAndWildcards","unstable_disableSSR","add","exactPath","render","literalSpec","pagePath","staticPaths","item","staticPath","definedPath","pathItems","mapping","expandStaticPathSpec","originalSpec","WrappedComponent","JSON","stringify","slices","createLayout","layout","createApi","options","handlers","GET","handler","createRoot","root","createSlice","ready","configure","getLayouts","pathSegments","reduce","acc","_segment","index","push","definedRouter","getConfigs","routeConfigs","rootIsStatic","noSsr","getPropsMapping","renderer","option","query","part","pathPattern","rootElement","routeElement","components","i","comp","apiConfigs","from","req","URL","url","method","all","sliceConfigs","pathConfigs","sort","configA","configB","slugIndex","forEach","join"],"mappings":"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"}