{"version":3,"sources":["../../src/router/util-types.ts"],"sourcesContent":["/**\n * Type version of `String.prototype.split()`. Splits the first string argument by the second string argument\n * @example\n * ```ts\n * // ['a', 'b', 'c']\n * type Case1 = Split<'abc', ''>\n * // ['a', 'b', 'c']\n * type Case2 = Split<'a,b,c', ','>\n * ```\n */\nexport type Split<\n  Str extends string,\n  Del extends string | number,\n> = string extends Str\n  ? string[]\n  : '' extends Str\n    ? []\n    : Str extends `${infer T}${Del}${infer U}`\n      ? [T, ...Split<U, Del>]\n      : [Str];\n\n/**\n * Accepts a boolean and returns `true` if the passed type is `false`, otherwise returns `true`\n * @example\n * ```ts\n * // false\n * type Case1 = Not<true>\n * // true\n * type Case2 = Not<false>\n * ```\n */\ntype Not<T extends boolean> = T extends true ? false : true;\n\n/**\n * Returns boolean whether the first argument extends the second argument\n * @example\n * ```ts\n * // true\n * type Case1 = Extends<1, number>\n * // false\n * type Case2 = Extends<number, 1>\n * ```\n */\ntype Extends<T, Base> = [T] extends [Base] ? true : false;\n\n/**\n * Returns boolean whether the first argument doesn't extend the second argument\n * @example\n * ```ts\n * // false\n * type Case1 = Extends<1, number>\n * // true\n * type Case2 = Extends<number, 1>\n * ```\n */\ntype NotExtends<T, Base> = Not<Extends<T, Base>>;\n\n/**\n * Returns a boolean whether the first array argument is fixed length tuple\n * @example\n * ```ts\n * // true\n * type Case1 = IsTuple<[1, 2, 3]>\n * // false\n * type Case2 = IsTuple<number[]>\n * ```\n */\ntype IsTuple<T extends readonly unknown[]> = NotExtends<number, T['length']>;\n\n/**\n * Returns the second argument if the first argument is `true` (defaults to `true`), otherwise returns the third argument (defaults to `false`)\n * ```ts\n * // valid\n * type Case1 = If<true, 'valid'>\n * // invalid\n * type Case2 = If<false, 'valid', 'invalid'>\n * ```\n */\ntype If<Condition, IfTrue = true, IfFalse = false> = Condition extends true\n  ? IfTrue\n  : IfFalse;\n\n/**\n * Returns the first argument if it is an empty array, otherwise returns `never`\n * @example\n * ```ts\n * // never\n * type Result = EmptyArray<[1]>\n * ```\n */\ntype EmptyArray<T extends readonly unknown[]> = T extends readonly [\n  unknown,\n  ...unknown[],\n]\n  ? never\n  : T;\n\n/**\n * Returns a boolean if the passed type is `never`\n * @example\n * ```ts\n * // true\n * type Case1 = IsNever<never>\n * // false\n * type Case2 = IsNever<true>\n * ```\n */\ntype IsNever<T> = [T] extends [never] ? true : false;\n\n/**\n * Returns a boolean whether the passed argument is an empty array\n * @example\n * ```ts\n * // false\n * type Result - IsEmptyArray<[1]>\n */\ntype IsEmptyArray<T extends readonly unknown[]> = If<\n  IsNever<EmptyArray<T>>,\n  false,\n  true\n>;\n\n/**\n *  Returns the second argument if the first argument is an empty array (defaults to `true`), otherwise returns the third argument (defaults to `false`)\n * @example\n * ```ts\n * // string\n * type Result = IfEmptyArray<[], string, number>\n * ```\n */\ntype IfEmptyArray<\n  T extends readonly unknown[],\n  IfTrue = true,\n  IfFalse = false,\n> = If<IsEmptyArray<T>, IfTrue, IfFalse>;\n\n/**\n * Type version of `Array.prototype.join()`. Joins the first array argument by the second argument\n * @example\n * ```ts\n * // 'a-p-p-l-e'\n * type Case1 = Join<[\"a\", \"p\", \"p\", \"l\", \"e\"], \"-\">\n * // '21212'\n * type Case2 = Join<[\"2\", \"2\", \"2\"], 1>\n * // 'o'\n * type Case3 = Join<[\"o\"], \"u\">\n * ```\n */\nexport type Join<\n  T extends readonly (string | number)[],\n  Glue extends string | number,\n> =\n  IsTuple<T> extends true\n    ? T extends readonly [\n        infer First extends string | number,\n        ...infer Rest extends readonly (string | number)[],\n      ]\n      ? IfEmptyArray<Rest, First, `${First}${Glue}${Join<Rest, Glue>}`>\n      : never\n    : never;\n\n/**\n * Replaces all occurrences of the second string argument with the third string argument in the first string argument\n * @example\n * ```ts\n * // 'remove him him'\n * type Case1 = ReplaceAll<'remove me me', 'me', 'him'>\n * // 'remove me me'\n * type Case2 = ReplaceAll<'remove me me', 'us', 'him'>\n * ```\n */\nexport type ReplaceAll<\n  T extends string,\n  Pivot extends string,\n  ReplaceBy extends string,\n> = T extends `${infer A}${Pivot}${infer B}`\n  ? ReplaceAll<`${A}${ReplaceBy}${B}`, Pivot, ReplaceBy>\n  : T;\n\n/**\n * This helper makes types more readable\n * @see https://www.totaltypescript.com/concepts/the-prettify-helper\n */\nexport type Prettify<T> = { [K in keyof T]: T[K] } & {};\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC,GA0KD;;;CAGC,GACD,WAAwD"}