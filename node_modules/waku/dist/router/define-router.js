import { jsx as _jsx } from "react/jsx-runtime";
import { createCustomError, getErrorInfo } from '../lib/utils/custom-errors.js';
import { getPathMapping } from '../lib/utils/path.js';
import { base64ToStream, streamToBase64 } from '../lib/utils/stream.js';
import { createTaskRunner } from '../lib/utils/task-runner.js';
import { unstable_defineHandlers as defineHandlers } from '../minimal/server.js';
import { unstable_getContext as getContext } from '../server.js';
import { INTERNAL_ServerRouter } from './client.js';
import { HAS404_ID, IS_STATIC_ID, ROUTE_ID, SKIP_HEADER, decodeRoutePath, decodeSliceId, encodeRoutePath, encodeSliceId } from './common.js';
const isStringArray = (x)=>Array.isArray(x) && x.every((y)=>typeof y === 'string');
const parseRscParams = (rscParams)=>{
    if (rscParams instanceof URLSearchParams) {
        return {
            query: rscParams.get('query') || ''
        };
    }
    if (typeof rscParams?.query === 'string') {
        return {
            query: rscParams.query
        };
    }
    return {
        query: ''
    };
};
const RSC_PATH_SYMBOL = Symbol('RSC_PATH');
const RSC_PARAMS_SYMBOL = Symbol('RSC_PARAMS');
const setRscPath = (rscPath)=>{
    try {
        const context = getContext();
        context[RSC_PATH_SYMBOL] = rscPath;
    } catch  {
    // ignore
    }
};
const setRscParams = (rscParams)=>{
    try {
        const context = getContext();
        context[RSC_PARAMS_SYMBOL] = rscParams;
    } catch  {
    // ignore
    }
};
export function unstable_getRscPath() {
    try {
        const context = getContext();
        return context[RSC_PATH_SYMBOL];
    } catch  {
        return undefined;
    }
}
export function unstable_getRscParams() {
    try {
        const context = getContext();
        return context[RSC_PARAMS_SYMBOL];
    } catch  {
        return undefined;
    }
}
const RERENDER_SYMBOL = Symbol('RERENDER');
const setRerender = (rerender)=>{
    try {
        const context = getContext();
        context[RERENDER_SYMBOL] = rerender;
    } catch  {
    // ignore
    }
};
const getRerender = ()=>{
    const context = getContext();
    return context[RERENDER_SYMBOL];
};
const is404 = (pathSpec)=>pathSpec.length === 1 && pathSpec[0].type === 'literal' && pathSpec[0].name === '404';
const pathSpec2pathname = (pathSpec)=>{
    if (pathSpec.some(({ type })=>type !== 'literal')) {
        return undefined;
    }
    return '/' + pathSpec.map(({ name })=>name).join('/');
};
const htmlPath2pathname = (htmlPath)=>htmlPath === '/404' ? '404.html' : htmlPath + '/index.html';
export function unstable_rerenderRoute(pathname, query) {
    const rscPath = encodeRoutePath(pathname);
    getRerender()(rscPath, query && new URLSearchParams({
        query
    }));
}
export function unstable_notFound() {
    throw createCustomError('Not Found', {
        status: 404
    });
}
export function unstable_redirect(location, status = 307) {
    throw createCustomError('Redirect', {
        status,
        location
    });
}
const ROOT_SLOT_ID = 'root';
const ROUTE_SLOT_ID_PREFIX = 'route:';
const SLICE_SLOT_ID_PREFIX = 'slice:';
const assertNonReservedSlotId = (slotId)=>{
    if (slotId === ROOT_SLOT_ID || slotId.startsWith(ROUTE_SLOT_ID_PREFIX) || slotId.startsWith(SLICE_SLOT_ID_PREFIX)) {
        throw new Error('Element ID cannot be "root", "route:*" or "slice:*"');
    }
};
export function unstable_defineRouter(fns) {
    let cachedMyConfig;
    const getMyConfig = async ()=>{
        if (!cachedMyConfig) {
            const configs = Array.from(await fns.getConfigs());
            let has404 = false;
            configs.forEach((item)=>{
                if (item.type === 'route') {
                    Object.keys(item.elements).forEach(assertNonReservedSlotId);
                    if (!has404 && is404(item.path)) {
                        has404 = true;
                    }
                }
            });
            cachedMyConfig = {
                configs,
                has404
            };
        }
        return cachedMyConfig;
    };
    const getPathConfigItem = async (pathname)=>{
        const myConfig = await getMyConfig();
        const found = myConfig.configs.find((item)=>(item.type === 'route' || item.type === 'api') && !!getPathMapping(item.path, pathname));
        return found;
    };
    const getSliceElement = async (sliceConfig, getCachedElement, setCachedElement)=>{
        const id = SLICE_SLOT_ID_PREFIX + sliceConfig.id;
        const cached = getCachedElement(id);
        if (cached) {
            return cached;
        }
        let element = await sliceConfig.renderer();
        if (sliceConfig.isStatic) {
            element = await setCachedElement(id, element);
        }
        return element;
    };
    const getEntriesForRoute = async (rscPath, rscParams, headers, getCachedElement, setCachedElement)=>{
        setRscPath(rscPath);
        setRscParams(rscParams);
        const pathname = decodeRoutePath(rscPath);
        const pathConfigItem = await getPathConfigItem(pathname);
        if (pathConfigItem?.type !== 'route') {
            return null;
        }
        let skipParam;
        try {
            skipParam = JSON.parse(headers[SKIP_HEADER.toLowerCase()] || '');
        } catch  {
        // ignore
        }
        const skipIdSet = new Set(isStringArray(skipParam) ? skipParam : []);
        const { query } = parseRscParams(rscParams);
        const decodedPathname = decodeURI(pathname);
        const routeId = ROUTE_SLOT_ID_PREFIX + decodedPathname;
        const option = {
            pathname: decodedPathname,
            query: pathConfigItem.isStatic ? undefined : query
        };
        const myConfig = await getMyConfig();
        const slices = pathConfigItem.slices || [];
        const sliceConfigMap = new Map();
        slices.forEach((sliceId)=>{
            const sliceConfig = myConfig.configs.find((item)=>item.type === 'slice' && item.id === sliceId);
            if (sliceConfig) {
                sliceConfigMap.set(sliceId, sliceConfig);
            }
        });
        const entries = {};
        await Promise.all([
            (async ()=>{
                if (!pathConfigItem.rootElement.isStatic) {
                    entries[ROOT_SLOT_ID] = pathConfigItem.rootElement.renderer(option);
                } else if (!skipIdSet.has(ROOT_SLOT_ID)) {
                    const cached = getCachedElement(ROOT_SLOT_ID);
                    entries[ROOT_SLOT_ID] = cached ? await cached : await setCachedElement(ROOT_SLOT_ID, pathConfigItem.rootElement.renderer(option));
                }
            })(),
            (async ()=>{
                if (!pathConfigItem.routeElement.isStatic) {
                    entries[routeId] = pathConfigItem.routeElement.renderer(option);
                } else if (!skipIdSet.has(routeId)) {
                    const cached = getCachedElement(routeId);
                    entries[routeId] = cached ? await cached : await setCachedElement(routeId, pathConfigItem.routeElement.renderer(option));
                }
            })(),
            ...Object.entries(pathConfigItem.elements).map(async ([id, { isStatic }])=>{
                const renderer = pathConfigItem.elements[id]?.renderer;
                if (!isStatic) {
                    entries[id] = renderer?.(option);
                } else if (!skipIdSet.has(id)) {
                    const cached = getCachedElement(id);
                    entries[id] = cached ? await cached : await setCachedElement(id, renderer?.(option));
                }
            }),
            ...slices.map(async (sliceId)=>{
                const id = SLICE_SLOT_ID_PREFIX + sliceId;
                const sliceConfig = sliceConfigMap.get(sliceId);
                if (!sliceConfig) {
                    throw new Error(`Slice not found: ${sliceId}`);
                }
                if (sliceConfig.isStatic && skipIdSet.has(id)) {
                    return null;
                }
                const sliceElement = await getSliceElement(sliceConfig, getCachedElement, setCachedElement);
                entries[id] = sliceElement;
            })
        ]);
        entries[ROUTE_ID] = [
            decodedPathname,
            query
        ];
        entries[IS_STATIC_ID] = pathConfigItem.isStatic;
        sliceConfigMap.forEach((sliceConfig, sliceId)=>{
            if (sliceConfig.isStatic) {
                // FIXME: hard-coded for now
                entries[IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + sliceId] = true;
            }
        });
        if (myConfig.has404) {
            entries[HAS404_ID] = true;
        }
        return entries;
    };
    const cachedElementsForRequest = new Map();
    let cachedElementsForRequestInitialized = false;
    const handleRequest = async (input, { renderRsc, parseRsc, renderHtml, loadBuildMetadata })=>{
        const getCachedElement = (id)=>cachedElementsForRequest.get(id);
        const setCachedElement = (id, element)=>{
            const cached = cachedElementsForRequest.get(id);
            if (cached) {
                return cached;
            }
            const copied = renderRsc({
                [id]: element
            }).then((rscStream)=>parseRsc(rscStream).then((parsed)=>parsed[id]));
            cachedElementsForRequest.set(id, copied);
            return copied;
        };
        if (!cachedElementsForRequestInitialized) {
            cachedElementsForRequestInitialized = true;
            const cachedElementsMetadata = await loadBuildMetadata('defineRouter:cachedElements');
            if (cachedElementsMetadata) {
                Object.entries(JSON.parse(cachedElementsMetadata)).forEach(([id, str])=>{
                    cachedElementsForRequest.set(id, parseRsc(base64ToStream(str)).then((parsed)=>parsed[id]));
                });
            }
        }
        const pathConfigItem = await getPathConfigItem(input.pathname);
        if (pathConfigItem?.type === 'api') {
            const url = new URL(input.req.url);
            url.pathname = input.pathname;
            const req = new Request(url, input.req);
            return pathConfigItem.handler(req);
        }
        const url = new URL(input.req.url);
        const headers = Object.fromEntries(input.req.headers.entries());
        if (input.type === 'component') {
            const sliceId = decodeSliceId(input.rscPath);
            if (sliceId !== null) {
                // LIMITATION: This is a signle slice request.
                // Ideally, we should be able to respond with multiple slices in one request.
                const sliceConfig = await getMyConfig().then((myConfig)=>myConfig.configs.find((item)=>item.type === 'slice' && item.id === sliceId));
                if (!sliceConfig) {
                    return null;
                }
                const sliceElement = await getSliceElement(sliceConfig, getCachedElement, setCachedElement);
                return renderRsc({
                    [SLICE_SLOT_ID_PREFIX + sliceId]: sliceElement,
                    ...sliceConfig.isStatic ? {
                        // FIXME: hard-coded for now
                        [IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + sliceId]: true
                    } : {}
                });
            }
            const entries = await getEntriesForRoute(input.rscPath, input.rscParams, headers, getCachedElement, setCachedElement);
            if (!entries) {
                return null;
            }
            return renderRsc(entries);
        }
        if (input.type === 'function') {
            let elementsPromise = Promise.resolve({});
            let rendered = false;
            const rerender = (rscPath, rscParams)=>{
                if (rendered) {
                    throw new Error('already rendered');
                }
                elementsPromise = Promise.all([
                    elementsPromise,
                    getEntriesForRoute(rscPath, rscParams, headers, getCachedElement, setCachedElement)
                ]).then(([oldElements, newElements])=>{
                    if (newElements === null) {
                        console.warn('getEntries returned null');
                    }
                    return {
                        ...oldElements,
                        ...newElements
                    };
                });
            };
            setRerender(rerender);
            try {
                const value = await input.fn(...input.args);
                return renderRsc({
                    ...await elementsPromise,
                    _value: value
                });
            } catch (e) {
                const info = getErrorInfo(e);
                if (info?.location) {
                    const rscPath = encodeRoutePath(info.location);
                    const entries = await getEntriesForRoute(rscPath, undefined, headers, getCachedElement, setCachedElement);
                    if (!entries) {
                        unstable_notFound();
                    }
                    return renderRsc(entries);
                }
                throw e;
            } finally{
                rendered = true;
            }
        }
        if (input.type === 'action' || input.type === 'custom') {
            const renderIt = async (pathname, query, httpstatus = 200)=>{
                const rscPath = encodeRoutePath(pathname);
                const rscParams = new URLSearchParams({
                    query
                });
                const entries = await getEntriesForRoute(rscPath, rscParams, headers, getCachedElement, setCachedElement);
                if (!entries) {
                    return null;
                }
                const html = /*#__PURE__*/ _jsx(INTERNAL_ServerRouter, {
                    route: {
                        path: pathname,
                        query,
                        hash: ''
                    },
                    httpstatus: httpstatus
                });
                const actionResult = input.type === 'action' ? await input.fn() : undefined;
                return renderHtml(await renderRsc(entries), html, {
                    rscPath,
                    actionResult,
                    status: httpstatus
                });
            };
            const query = url.searchParams.toString();
            if (pathConfigItem?.type === 'route' && pathConfigItem.noSsr) {
                return 'fallback';
            }
            try {
                if (pathConfigItem) {
                    return await renderIt(input.pathname, query);
                }
            } catch (e) {
                const info = getErrorInfo(e);
                if (info?.status !== 404) {
                    throw e;
                }
            }
            if ((await getMyConfig()).has404) {
                return renderIt('/404', '', 404);
            } else {
                return null;
            }
        }
    };
    const handleBuild = async ({ renderRsc, parseRsc, renderHtml, rscPath2pathname, saveBuildMetadata, withRequest, generateFile, generateDefaultHtml })=>{
        const myConfig = await getMyConfig();
        const cachedElementsForBuild = new Map();
        const serializedCachedElements = new Map();
        const getCachedElement = (id)=>cachedElementsForBuild.get(id);
        const setCachedElement = async (id, element)=>{
            const cached = cachedElementsForBuild.get(id);
            if (cached) {
                return cached;
            }
            const teedStream = renderRsc({
                [id]: element
            }).then((rscStream)=>rscStream.tee());
            const stream1 = teedStream.then(([s1])=>s1);
            const stream2 = teedStream.then(([, s2])=>s2);
            const copied = stream1.then((rscStream)=>parseRsc(rscStream).then((parsed)=>parsed[id]));
            cachedElementsForBuild.set(id, copied);
            serializedCachedElements.set(id, await streamToBase64(await stream2));
            return copied;
        };
        // hard-coded concurrency limit
        const { runTask, waitForTasks } = createTaskRunner(500);
        // static api
        for (const item of myConfig.configs){
            if (item.type !== 'api') {
                continue;
            }
            if (!item.isStatic) {
                continue;
            }
            const pathname = pathSpec2pathname(item.path);
            if (!pathname) {
                continue;
            }
            const req = new Request(new URL(pathname, 'http://localhost:3000'));
            runTask(async ()=>{
                await withRequest(req, async ()=>{
                    const res = await item.handler(req);
                    await generateFile(pathname, res.body || '');
                });
            });
        }
        // static route
        for (const item of myConfig.configs){
            if (item.type !== 'route') {
                continue;
            }
            if (!item.isStatic) {
                continue;
            }
            const pathname = pathSpec2pathname(item.path);
            if (!pathname) {
                continue;
            }
            const rscPath = encodeRoutePath(pathname);
            const req = new Request(new URL(pathname, 'http://localhost:3000'));
            runTask(async ()=>{
                await withRequest(req, async ()=>{
                    const entries = await getEntriesForRoute(rscPath, undefined, {}, getCachedElement, setCachedElement);
                    if (!entries) {
                        return;
                    }
                    for (const id of Object.keys(entries)){
                        const cached = getCachedElement(id);
                        entries[id] = cached ? await cached : entries[id];
                    }
                    const stream = await renderRsc(entries);
                    const [stream1, stream2] = stream.tee();
                    await generateFile(rscPath2pathname(rscPath), stream1);
                    const html = /*#__PURE__*/ _jsx(INTERNAL_ServerRouter, {
                        route: {
                            path: pathname,
                            query: '',
                            hash: ''
                        },
                        httpstatus: is404(item.path) ? 404 : 200
                    });
                    const res = await renderHtml(stream2, html, {
                        rscPath
                    });
                    await generateFile(htmlPath2pathname(pathname), res.body || '');
                });
            });
        }
        // default html
        for (const item of myConfig.configs){
            if (item.type !== 'route') {
                continue;
            }
            if (item.noSsr) {
                const pathname = pathSpec2pathname(item.path);
                if (!pathname) {
                    throw new Error('Pathname is required for noSsr routes on build');
                }
                runTask(async ()=>{
                    await generateDefaultHtml(htmlPath2pathname(pathname));
                });
            }
        }
        // static slice
        for (const item of myConfig.configs){
            if (item.type !== 'slice') {
                continue;
            }
            if (!item.isStatic) {
                continue;
            }
            const rscPath = encodeSliceId(item.id);
            // dummy req for slice which is not determined at build time
            const req = new Request(new URL('http://localhost:3000'));
            runTask(async ()=>{
                await withRequest(req, async ()=>{
                    const sliceElement = await getSliceElement(item, getCachedElement, setCachedElement);
                    const body = await renderRsc({
                        [SLICE_SLOT_ID_PREFIX + item.id]: sliceElement,
                        // FIXME: hard-coded for now
                        [IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + item.id]: true
                    });
                    await generateFile(rscPath2pathname(rscPath), body);
                });
            });
        }
        await waitForTasks();
        // TODO should we save serialized cached elements separately?
        await saveBuildMetadata('defineRouter:cachedElements', JSON.stringify(Object.fromEntries(serializedCachedElements)));
    };
    return Object.assign(defineHandlers({
        handleRequest,
        handleBuild
    }), {
        unstable_getRouterConfigs: ()=>getMyConfig().then((c)=>c.configs)
    });
}

//# sourceMappingURL=define-router.js.map